{
  "address": "0x36E8C60Ebf4Ce520C820F9389BBfCE8dA83Dfbc1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ENS",
          "name": "_ensRegistry",
          "type": "address"
        },
        {
          "internalType": "contract IENSGuilds",
          "name": "ensGuilds",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "reverseRecordOwner",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "TokenIDTagMustMatchCallerTokenID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "claimant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "extraClaimArgs",
          "type": "bytes"
        }
      ],
      "name": "canClaimTag",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "extraRevokeArgs",
          "type": "bytes"
        }
      ],
      "name": "canRevokeTag",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "transferredBy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "currentOwner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "canTransferTag",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ensGuilds",
      "outputs": [
        {
          "internalType": "contract IENSGuilds",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "guilds",
      "outputs": [
        {
          "internalType": "address",
          "name": "tokenContract",
          "type": "address"
        },
        {
          "internalType": "enum NFTTagsAuthPolicy.TokenStandard",
          "name": "tokenStandard",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "claimant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "extraClaimArgs",
          "type": "bytes"
        }
      ],
      "name": "onTagClaimed",
      "outputs": [
        {
          "internalType": "string",
          "name": "tagToRevoke",
          "type": "string"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "revokedBy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "revokedFrom",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        }
      ],
      "name": "onTagRevoked",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "transferredBy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "prevOwner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "onTagTransferred",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildEnsNode",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "tokenContract",
          "type": "address"
        }
      ],
      "name": "setTokenContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xbf8675e40157f975baabdd4446cb8764ae42cae98b546da52a8604184dc39f92",
  "receipt": {
    "to": null,
    "from": "0xB6a6c32CCe5B5E963277A66019309EBf13f59F12",
    "contractAddress": "0x36E8C60Ebf4Ce520C820F9389BBfCE8dA83Dfbc1",
    "transactionIndex": 66,
    "gasUsed": "1231919",
    "logsBloom": "0x00000000000000000800000800000000000000000000000000000000000000000000140000000000100002000000000000000000000010000000000000020000000000000000000040200000008000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000020000000200000000000000000000000000000040000000010000000000004000000000001008000040000000000000000000000000080000000005000000000000000000000000000000000000000000000000000000000000100000000000000001000000000000000000000",
    "blockHash": "0xdeb61ad6149002d175146ac8a8eb8c6093efd59619e11d008235c5b63e0f3a1f",
    "transactionHash": "0xbf8675e40157f975baabdd4446cb8764ae42cae98b546da52a8604184dc39f92",
    "logs": [
      {
        "transactionIndex": 66,
        "blockNumber": 17939394,
        "transactionHash": "0xbf8675e40157f975baabdd4446cb8764ae42cae98b546da52a8604184dc39f92",
        "address": "0xa58E81fe9b61B5c3fE2AFD33CF304c454AbFc7Cb",
        "topics": [
          "0x6ada868dd3058cf77a48a74489fd7963688e5464b2b0fa957ace976243270e92",
          "0x00000000000000000000000036e8c60ebf4ce520c820f9389bbfce8da83dfbc1",
          "0x1697b4a7cb16013ed78753e898026a447f8f0ba7f64d194413abadfa874786c8"
        ],
        "data": "0x",
        "logIndex": 152,
        "blockHash": "0xdeb61ad6149002d175146ac8a8eb8c6093efd59619e11d008235c5b63e0f3a1f"
      },
      {
        "transactionIndex": 66,
        "blockNumber": 17939394,
        "transactionHash": "0xbf8675e40157f975baabdd4446cb8764ae42cae98b546da52a8604184dc39f92",
        "address": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        "topics": [
          "0xce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82",
          "0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2",
          "0xe1cdb3ce153b07d58922b60b99e7eb26c0390316a9f77b3c8e074693ba9dda9b"
        ],
        "data": "0x000000000000000000000000c17cb209d5abdb2d00f566a1e48f558debc264e1",
        "logIndex": 153,
        "blockHash": "0xdeb61ad6149002d175146ac8a8eb8c6093efd59619e11d008235c5b63e0f3a1f"
      },
      {
        "transactionIndex": 66,
        "blockNumber": 17939394,
        "transactionHash": "0xbf8675e40157f975baabdd4446cb8764ae42cae98b546da52a8604184dc39f92",
        "address": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        "topics": [
          "0x335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a0",
          "0x1697b4a7cb16013ed78753e898026a447f8f0ba7f64d194413abadfa874786c8"
        ],
        "data": "0x000000000000000000000000231b0ee14048e9dccd1d247744d114a4eb5e8e63",
        "logIndex": 154,
        "blockHash": "0xdeb61ad6149002d175146ac8a8eb8c6093efd59619e11d008235c5b63e0f3a1f"
      }
    ],
    "blockNumber": 17939394,
    "cumulativeGasUsed": "6219338",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    "0xF03021AAa150C0d3A57E62D2C64B4b8C064be8B1",
    "0xc17cB209D5aBdb2d00f566a1E48F558DEBC264E1"
  ],
  "numDeployments": 1,
  "solcInputHash": "7331d540f29a35a261d4daf89b5d421d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"_ensRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IENSGuilds\",\"name\":\"ensGuilds\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reverseRecordOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TokenIDTagMustMatchCallerTokenID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraClaimArgs\",\"type\":\"bytes\"}],\"name\":\"canClaimTag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"extraRevokeArgs\",\"type\":\"bytes\"}],\"name\":\"canRevokeTag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"transferredBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"canTransferTag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensGuilds\",\"outputs\":[{\"internalType\":\"contract IENSGuilds\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"guilds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"enum NFTTagsAuthPolicy.TokenStandard\",\"name\":\"tokenStandard\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraClaimArgs\",\"type\":\"bytes\"}],\"name\":\"onTagClaimed\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tagToRevoke\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"revokedBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"revokedFrom\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"}],\"name\":\"onTagRevoked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"transferredBy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"onTagTransferred\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildEnsNode\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"canClaimTag(bytes32,string,address,address,bytes)\":{\"details\":\"Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`. The caller must own the given TokenID.\",\"params\":{\"claimant\":\"The address attempting to claim the tag (not necessarily the address that will receive it)\",\"extraClaimArgs\":\"[Optional] Any guild-specific additional arguments required\",\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"recipient\":\"The address that would receive the tag\",\"tag\":\"The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\"}},\"canRevokeTag(address,bytes32,string,bytes)\":{\"params\":{\"extraRevokeArgs\":\"Any additional arguments necessary for assessing whether a tag may be revoked\",\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"revokedBy\":\"The address that would attempt to revoke it\",\"tag\":\"The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\"}},\"canTransferTag(bytes32,string,address,address,address,bytes)\":{\"params\":{\"currentOwner\":\"The address currently owning the given tag\",\"extraTransferArgs\":\"Any additional arguments necessary for assessing whether a tag may be transferred\",\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"newOwner\":\"The address that would receive the tag\",\"tag\":\"The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\",\"transferredBy\":\"The address initiating the transfer. May be different than the currentOwner, such as an admin or a marketplace contract\"}},\"onTagClaimed(bytes32,string,address,address,bytes)\":{\"details\":\"protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.\",\"params\":{\"claimant\":\"The address that claimed the tag (not necessarily the address that received it)\",\"extraClaimArgs\":\"[Optional] Any guild-specific additional arguments required\",\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"recipient\":\"The address that received receive the tag\",\"tag\":\"The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\"},\"returns\":{\"tagToRevoke\":\"Any tag that should be revoked as a consequence of the given tag being claimed. Returns empty string if no tag should be revoked.\"}},\"onTagRevoked(address,address,bytes32,string)\":{\"details\":\"protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.\",\"params\":{\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"revokedBy\":\"The address that revoked it\",\"revokedFrom\":\"The address who owned it when it was revoked\",\"tag\":\"The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\"}},\"onTagTransferred(bytes32,string,address,address,address)\":{\"details\":\"protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.\",\"params\":{\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"newOwner\":\"The address that received the tag\",\"prevOwner\":\"The address that previously owned the tag\",\"tag\":\"The tag that was transferred\",\"transferredBy\":\"The address initiating the transfer\"}},\"setTokenContract(bytes32,address)\":{\"params\":{\"guildEnsNode\":\"The ENS namehash of the guild's domain\",\"tokenContract\":\"The ERC721 or ERC1155 collection to use\"}}},\"title\":\"NFTTagsAuthPolicy\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"canClaimTag(bytes32,string,address,address,bytes)\":{\"notice\":\"Checks whether a certain address (claimant) may claim a given guild tag that has been revoked or has never been claimed\"},\"canRevokeTag(address,bytes32,string,bytes)\":{\"notice\":\"Checks whether a given guild tag is eligible to be revoked\"},\"canTransferTag(bytes32,string,address,address,address,bytes)\":{\"notice\":\"Checks whether a tag can be transferred. Implementations may trust that `currentOwner` is the owner of the given tag.\"},\"onTagRevoked(address,address,bytes32,string)\":{\"notice\":\"Called by ENSGuilds once a tag has been revoked.\"},\"onTagTransferred(bytes32,string,address,address,address)\":{\"notice\":\"Called by ENSGuilds once a tag has been transferred\"},\"setTokenContract(bytes32,address)\":{\"notice\":\"Registers the specific NFT collection that a user must be a member of to mint a guild tag\"}},\"notice\":\"A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being revoked once the second is minted, regardless of whether ownership of that TokenID has changed. A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol\":\"NFTTagsAuthPolicy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function setRecord(\\n        bytes32 node,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeRecord(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner,\\n        address resolver,\\n        uint64 ttl\\n    ) external;\\n\\n    function setSubnodeOwner(\\n        bytes32 node,\\n        bytes32 label,\\n        address owner\\n    ) external returns (bytes32);\\n\\n    function setResolver(bytes32 node, address resolver) external;\\n\\n    function setOwner(bytes32 node, address owner) external;\\n\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function owner(bytes32 node) external view returns (address);\\n\\n    function resolver(bytes32 node) external view returns (address);\\n\\n    function ttl(bytes32 node) external view returns (uint64);\\n\\n    function recordExists(bytes32 node) external view returns (bool);\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x7cb1158c7d268b63de1468e28e2711b28d686e2628ddb22da2149cd93ddeafda\"},\"@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\ninterface IReverseRegistrar {\\n    function setDefaultResolver(address resolver) external;\\n\\n    function claim(address owner) external returns (bytes32);\\n\\n    function claimForAddr(\\n        address addr,\\n        address owner,\\n        address resolver\\n    ) external returns (bytes32);\\n\\n    function claimWithResolver(\\n        address owner,\\n        address resolver\\n    ) external returns (bytes32);\\n\\n    function setName(string memory name) external returns (bytes32);\\n\\n    function setNameForAddr(\\n        address addr,\\n        address owner,\\n        address resolver,\\n        string memory name\\n    ) external returns (bytes32);\\n\\n    function node(address addr) external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x83adfcf6da72b1bcd1e3ac387afe5fc7fdf7f2ac28b7601544d2ca4b9d45d159\"},\"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17 <0.9.0;\\n\\nimport {ENS} from \\\"../registry/ENS.sol\\\";\\nimport {IReverseRegistrar} from \\\"../reverseRegistrar/IReverseRegistrar.sol\\\";\\n\\ncontract ReverseClaimer {\\n    bytes32 constant ADDR_REVERSE_NODE =\\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\\n\\n    constructor(ENS ens, address claimant) {\\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\\n            ens.owner(ADDR_REVERSE_NODE)\\n        );\\n        reverseRegistrar.claim(claimant);\\n    }\\n}\\n\",\"keccak256\":\"0x78a28627241535b595f6fff476a1fa7acc90c80684fe7784734920fc8af6fc22\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xa535a5df777d44e945dd24aa43a11e44b024140fc340ad0dfe42acf4002aade1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/ensGuilds/interfaces/IENSGuilds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { IERC1155MetadataURI } from \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\n\\ninterface IENSGuilds is IERC1155MetadataURI {\\n    /** Events */\\n    event Registered(bytes32 indexed guildEnsNode);\\n    event Deregistered(bytes32 indexed guildEnsNode);\\n    event TagClaimed(bytes32 indexed guildEnsNode, bytes32 indexed tagHash, address recipient);\\n    event TagTransferred(bytes32 indexed guildEnsNode, bytes32 indexed tagHash, address from, address to);\\n    event TagRevoked(bytes32 indexed guildEnsNode, bytes32 indexed tagHash);\\n    event FeePolicyUpdated(bytes32 indexed guildEnsNode, address feePolicy);\\n    event TagsAuthPolicyUpdated(bytes32 indexed guildEnsNode, address tagsAuthPolicy);\\n    event AdminTransferred(bytes32 indexed guildEnsNode, address newAdmin);\\n    event SetActive(bytes32 indexed guildEnsNode, bool active);\\n    event TokenUriSet(bytes32 indexed guildEnsNode, string uri);\\n\\n    /* Functions */\\n\\n    /**\\n     * @notice Registers a new guild from an existing ENS domain.\\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \\\"operator\\\" for the caller.\\n     * @param ensName The guild's full ENS name (e.g. 'my-guild.eth')\\n     * @param guildAdmin The address that will administrate this guild\\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for minting new tags\\n     * within this guild\\n     */\\n    function registerGuild(\\n        string calldata ensName,\\n        address guildAdmin,\\n        address feePolicy,\\n        address tagsAuthPolicy\\n    ) external;\\n\\n    /**\\n     * @notice De-registers a registered guild.\\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     */\\n    function deregisterGuild(bytes32 guildEnsNode) external;\\n\\n    /**\\n     * @notice Claims a guild tag\\n     * @param guildEnsNode The namehash of the guild for which the tag should be claimed (e.g. namehash('my-guild.eth'))\\n     * @param tag The tag name to claim (e.g. 'foo' for foo.my-guild.eth). Assumes `tag` is already normalized per\\n     * ENS Name Processing rules\\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\\n     *  such as authorization\\n     */\\n    function claimGuildTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external payable;\\n\\n    /**\\n     * @notice Transfers an existing guild tag\\n     * @param guildEnsNode The namehash of the guild for which the tag should be transferred\\n     * (e.g. namehash('my-guild.eth'))\\n     * @param tag The tag name to transfer (e.g. 'foo' for foo.my-guild.eth). Assumes `tag` is already normalized per\\n     * ENS Name Processing rules\\n     * @param recipient The address that will receive this guild tag\\n     * @param extraTransferArgs [Optional] Any additional arguments necessary for guild-specific logic,\\n     *  such as authorization\\n     */\\n    function transferGuildTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address recipient,\\n        bytes calldata extraTransferArgs\\n    ) external;\\n\\n    /**\\n     * @notice Claims multiple tags for a guild at once\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tags Tags to be claimed\\n     * @param recipients Recipients of each tag to be claimed\\n     * @param extraClaimArgs Per-tag extra arguments required for guild-specific logic, such as authorization.\\n     * Must have same length as array of tagHashes, even if each array element is itself empty bytes\\n     */\\n    function claimGuildTagsBatch(\\n        bytes32 guildEnsNode,\\n        string[] calldata tags,\\n        address[] calldata recipients,\\n        bytes[] calldata extraClaimArgs\\n    ) external payable;\\n\\n    /**\\n     * @notice Returns the current owner of the given guild tag.\\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\\n     */\\n    function tagOwner(bytes32 guildEnsNode, bytes32 tagHash) external view returns (address);\\n\\n    /**\\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag to revoke\\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function revokeGuildTag(bytes32 guildEnsNode, string calldata tag, bytes calldata extraData) external;\\n\\n    /**\\n     * @notice Attempts to revoke multiple guild tags\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tags tags to revoke\\n     * @param extraData Additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function revokeGuildTagsBatch(bytes32 guildEnsNode, string[] calldata tags, bytes[] calldata extraData) external;\\n\\n    /**\\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\\n     */\\n    function updateGuildFeePolicy(bytes32 guildEnsNode, address feePolicy) external;\\n\\n    /**\\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for\\n     * minting new tags within this guild\\n     */\\n    function updateGuildTagsAuthPolicy(bytes32 guildEnsNode, address tagsAuthPolicy) external;\\n\\n    /**\\n     * @notice Sets the metadata URI string for fetching metadata for a guild's tag NFTs.\\n     * May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param uri The ERC1155 metadata URL template\\n     */\\n    function setGuildTokenUri(bytes32 guildEnsNode, string calldata uri) external;\\n\\n    /**\\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param active The new status\\n     */\\n    function setGuildActive(bytes32 guildEnsNode, bool active) external;\\n\\n    /**\\n     * @notice Returns the current admin registered for the given guild.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     */\\n    function guildAdmin(bytes32 guildEnsNode) external view returns (address);\\n\\n    /**\\n     * @notice Transfers the role of guild admin to the given address.\\n     * May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param newAdmin The new admin\\n     */\\n    function transferGuildAdmin(bytes32 guildEnsNode, address newAdmin) external;\\n\\n    /**\\n     * @notice Registers a resolver for the guild's root ENS name that will\\n     * answer queries about the parent name itself, or any child names that are\\n     * not Guild tags\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param fallbackResolver The fallback resolver\\n     */\\n    function setFallbackResolver(bytes32 guildEnsNode, address fallbackResolver) external;\\n}\\n\",\"keccak256\":\"0xdd1351df064ede50cdf43fa12e52be847dda264f534acf845096ad4e43343e84\",\"license\":\"MIT\"},\"contracts/libraries/StringParsing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary StringParsing {\\n    /**\\n     * @dev Parses a UTF8 string of digits representing an unsigned integer.\\n     */\\n    function parseUint256(bytes calldata b) internal pure returns (bool valid, uint256 parsed) {\\n        uint256 i;\\n        parsed = 0;\\n        for (i = 0; i < b.length; i++) {\\n            if (b[i] < bytes1(0x30) || b[i] > bytes1(0x39)) {\\n                return (false, 0);\\n            }\\n            uint256 c = uint(uint8(b[i])) - 48;\\n            parsed = parsed * 10 + c;\\n        }\\n        return (true, parsed);\\n    }\\n}\\n\",\"keccak256\":\"0xef8359450817d6057bbfaf54090d63e062d867f83056d448be3fcb11208511bc\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/BaseTagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { ERC165 } from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport { Context } from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport { ITagsAuthPolicy } from \\\"./ITagsAuthPolicy.sol\\\";\\nimport { IENSGuilds } from \\\"../ensGuilds/interfaces/IENSGuilds.sol\\\";\\n\\n/**\\n * @title BaseTagsAuthPolicy\\n * @notice An base implementation of ITagsAuthPolicy\\n */\\nabstract contract BaseTagsAuthPolicy is ITagsAuthPolicy, ERC165, Context, ReentrancyGuard {\\n    using ERC165Checker for address;\\n\\n    IENSGuilds public immutable ensGuilds;\\n\\n    constructor(IENSGuilds _ensGuilds) {\\n        // solhint-disable-next-line reason-string, custom-errors\\n        require(_ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\\n        ensGuilds = _ensGuilds;\\n    }\\n\\n    modifier onlyEnsGuildsContract() {\\n        // solhint-disable-next-line reason-string, custom-errors\\n        require(_msgSender() == address(ensGuilds));\\n        _;\\n    }\\n\\n    modifier onlyGuildAdmin(bytes32 guildEnsNode) {\\n        // solhint-disable-next-line reason-string, custom-errors\\n        require(ensGuilds.guildAdmin(guildEnsNode) == _msgSender());\\n        _;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\\n     * is deferred to the implementation.\\n     */\\n    function onTagClaimed(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external override nonReentrant onlyEnsGuildsContract returns (string memory tagToRevoke) {\\n        return _onTagClaimed(guildEnsNode, tag, claimant, recipient, extraClaimArgs);\\n    }\\n\\n    /**\\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\\n     */\\n    function _onTagClaimed(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) internal virtual returns (string memory tagToRevoke);\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\\n     * is deferred to the implementation.\\n     */\\n    function onTagRevoked(\\n        address revokedBy,\\n        address revokedFrom,\\n        bytes32 guildEnsNode,\\n        string memory tag\\n    ) external override nonReentrant onlyEnsGuildsContract {\\n        _onTagRevoked(revokedBy, revokedFrom, guildEnsNode, tag);\\n    }\\n\\n    /**\\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\\n     */\\n    function _onTagRevoked(\\n        address revokedBy,\\n        address revokedFrom,\\n        bytes32 guildEnsNode,\\n        string memory tag\\n    ) internal virtual;\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\\n     * is deferred to the implementation.\\n     */\\n    function onTagTransferred(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address transferredBy,\\n        address prevOwner,\\n        address newOwner\\n    ) external override nonReentrant onlyEnsGuildsContract {\\n        _onTagTransferred(guildEnsNode, tag, transferredBy, prevOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\\n     */\\n    function _onTagTransferred(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address transferredBy,\\n        address prevOwner,\\n        address newOwner\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x1078df04ec110e97b6f62360e41dd351410b3ae9d68f53563a3be2c4cf12af7a\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/ITagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title TagsAuthPolicy\\n * @notice An interface for Guilds to implement that will control authorization for minting tags within that guild\\n */\\ninterface ITagsAuthPolicy is IERC165 {\\n    /**\\n     * @notice Checks whether a certain address (claimant) may claim a given guild tag that has been revoked or\\n     * has never been claimed\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\\n     * @param recipient The address that would receive the tag\\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\\n     */\\n    function canClaimTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Called by ENSGuilds once a tag has been claimed.\\n     * Provided for auth policies to update local state, such as erasing an address from an allowlist after that\\n     * address has successfully minted a tag.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\\n     * @param claimant The address that claimed the tag (not necessarily the address that received it)\\n     * @param recipient The address that received receive the tag\\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\\n     * @return tagToRevoke Any tag that should be revoked as a consequence of the given tag\\n     * being claimed. Returns empty string if no tag should be revoked.\\n     */\\n    function onTagClaimed(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external returns (string memory tagToRevoke);\\n\\n    /**\\n     * @notice Checks whether a given guild tag is eligible to be revoked\\n     * @param revokedBy The address that would attempt to revoke it\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\\n     * @param extraRevokeArgs Any additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function canRevokeTag(\\n        address revokedBy,\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        bytes calldata extraRevokeArgs\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Called by ENSGuilds once a tag has been revoked.\\n     * @param revokedBy The address that revoked it\\n     * @param revokedFrom The address who owned it when it was revoked\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\\n     */\\n    function onTagRevoked(address revokedBy, address revokedFrom, bytes32 guildEnsNode, string memory tag) external;\\n\\n    /**\\n     * @notice Checks whether a tag can be transferred. Implementations may trust that `currentOwner` is the\\n     * owner of the given tag.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\\n     * @param transferredBy The address initiating the transfer. May be different than the currentOwner, such\\n     * as an admin or a marketplace contract\\n     * @param currentOwner The address currently owning the given tag\\n     * @param newOwner The address that would receive the tag\\n     * @param extraTransferArgs Any additional arguments necessary for assessing whether a tag may be transferred\\n     */\\n    function canTransferTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address transferredBy,\\n        address currentOwner,\\n        address newOwner,\\n        bytes calldata extraTransferArgs\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Called by ENSGuilds once a tag has been transferred\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag that was transferred\\n     * @param transferredBy The address initiating the transfer\\n     * @param prevOwner The address that previously owned the tag\\n     * @param newOwner The address that received the tag\\n     */\\n    function onTagTransferred(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address transferredBy,\\n        address prevOwner,\\n        address newOwner\\n    ) external;\\n}\\n\",\"keccak256\":\"0xc676e612890e85f7cfa4a6e0e60129d9d77c224525d890f11f8eeb27c350d8b5\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport { ReverseClaimer } from \\\"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\\\";\\nimport { ENS } from \\\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\\\";\\nimport { ERC165Checker } from \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport { IERC721 } from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport { IERC1155 } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport { StringParsing } from \\\"../libraries/StringParsing.sol\\\";\\nimport { BaseTagsAuthPolicy } from \\\"./BaseTagsAuthPolicy.sol\\\";\\nimport { IENSGuilds } from \\\"../ensGuilds/interfaces/IENSGuilds.sol\\\";\\nimport { ITagsAuthPolicy } from \\\"./ITagsAuthPolicy.sol\\\"; // solhint-disable-line no-unused-import\\n\\n/**\\n * @title NFTTagsAuthPolicy\\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses\\n * that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once\\n * per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being\\n * revoked once the second is minted, regardless of whether ownership of that TokenID has changed.\\n *\\n * A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\\n */\\ncontract NFTTagsAuthPolicy is BaseTagsAuthPolicy, ReverseClaimer {\\n    using ERC165Checker for address;\\n    using StringParsing for bytes;\\n    using Strings for string;\\n\\n    error TokenIDTagMustMatchCallerTokenID();\\n\\n    enum TokenStandard {\\n        ERC721,\\n        ERC1155\\n    }\\n    struct TagClaim {\\n        string tag;\\n        address claimedBy;\\n    }\\n    struct GuildInfo {\\n        address tokenContract;\\n        TokenStandard tokenStandard;\\n        mapping(uint256 => TagClaim) tagClaims;\\n    }\\n    mapping(bytes32 => GuildInfo) public guilds;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(\\n        ENS _ensRegistry,\\n        IENSGuilds ensGuilds,\\n        address reverseRecordOwner\\n    ) BaseTagsAuthPolicy(ensGuilds) ReverseClaimer(_ensRegistry, reverseRecordOwner) {}\\n\\n    /**\\n     * @notice Registers the specific NFT collection that a user must be a member of to mint a guild tag\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tokenContract The ERC721 or ERC1155 collection to use\\n     */\\n    function setTokenContract(bytes32 guildEnsNode, address tokenContract) external onlyGuildAdmin(guildEnsNode) {\\n        // token contract must be ERC721 or ERC1155\\n        if (tokenContract.supportsInterface(type(IERC721).interfaceId)) {\\n            guilds[guildEnsNode].tokenStandard = TokenStandard.ERC721;\\n        } else if (tokenContract.supportsInterface(type(IERC1155).interfaceId)) {\\n            guilds[guildEnsNode].tokenStandard = TokenStandard.ERC1155;\\n        } else {\\n            // solhint-disable-next-line reason-string, custom-errors\\n            revert();\\n        }\\n\\n        guilds[guildEnsNode].tokenContract = tokenContract;\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`.\\n     * The caller must own the given TokenID.\\n     */\\n    function canClaimTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address,\\n        bytes calldata extraClaimArgs\\n    ) external view virtual override returns (bool) {\\n        GuildInfo storage guildInfo = guilds[guildEnsNode];\\n        address tokenContract = guildInfo.tokenContract;\\n\\n        // parse NFT token ID from the tag claim args\\n        if (extraClaimArgs.length != 32) {\\n            return false;\\n        }\\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\\n\\n        // check that claimant owns this NFT\\n        bool ownsNFT = false;\\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\\n            ownsNFT = IERC721(tokenContract).ownerOf(nftTokenId) == claimant;\\n        } else {\\n            ownsNFT = IERC1155(tokenContract).balanceOf(claimant, nftTokenId) > 0;\\n        }\\n        if (!ownsNFT) {\\n            return false;\\n        }\\n\\n        // if the tag looks like a token ID, it should be the same as the token ID\\n        // used to authorize the mint\\n        (bool isUint, uint256 parsedTokenID) = bytes(tag).parseUint256();\\n        if (isUint && parsedTokenID != nftTokenId) {\\n            revert TokenIDTagMustMatchCallerTokenID();\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev records the latest tag minted from the given TokenID (via extraClaimArgs), and returns whichever\\n     * tag was last minted from the same TokenID.\\n     */\\n    function _onTagClaimed(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address claimant,\\n        address,\\n        bytes calldata extraClaimArgs\\n    ) internal virtual override returns (string memory tagToRevoke) {\\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\\n\\n        tagToRevoke = guilds[guildEnsNode].tagClaims[nftTokenId].tag;\\n\\n        guilds[guildEnsNode].tagClaims[nftTokenId].tag = tag;\\n        guilds[guildEnsNode].tagClaims[nftTokenId].claimedBy = claimant;\\n\\n        return tagToRevoke;\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     */\\n    function canRevokeTag(\\n        address,\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        bytes calldata extraRevokeArgs\\n    ) external view virtual override returns (bool) {\\n        if (extraRevokeArgs.length != 32) {\\n            return false;\\n        }\\n        uint256 nftTokenId = uint256(bytes32(extraRevokeArgs));\\n\\n        GuildInfo storage guildInfo = guilds[guildEnsNode];\\n        address tokenContract = guildInfo.tokenContract;\\n\\n        // check that the given tag was indeed claimed from the given NFT\\n        if (!guildInfo.tagClaims[nftTokenId].tag.equal(tag)) {\\n            return false;\\n        }\\n\\n        // check that the current owner of the given NFT is the same as the owner when the tag was claimed\\n        address previousClaimant = guildInfo.tagClaims[nftTokenId].claimedBy;\\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\\n            address currentTokenOwner = IERC721(tokenContract).ownerOf(nftTokenId);\\n            return currentTokenOwner != previousClaimant;\\n        } else {\\n            return IERC1155(tokenContract).balanceOf(previousClaimant, nftTokenId) == 0;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     */\\n    function canTransferTag(\\n        bytes32,\\n        string calldata,\\n        address transferredBy,\\n        address currentOwner,\\n        address,\\n        bytes calldata\\n    ) external pure returns (bool) {\\n        return transferredBy == currentOwner;\\n    }\\n\\n    function _onTagRevoked(address, address, bytes32, string memory) internal virtual override {\\n        return;\\n    }\\n\\n    function _onTagTransferred(bytes32, string calldata, address, address, address) internal virtual override {\\n        return;\\n    }\\n}\\n\",\"keccak256\":\"0x6bdc0d45b098f26727fbd8d4c77be77528ee519fb54b3b150071b71791a3dccd\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162001656380380620016568339810160408190526200003491620001e8565b60016000556040516301ffc9a760e01b81526301d37a4160e51b60048201528390829084906001600160a01b038216906301ffc9a790602401602060405180830381865afa1580156200008b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000b191906200023c565b620000bb57600080fd5b6001600160a01b039081166080526040516302571be360e01b81527f91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e260048201526000918416906302571be390602401602060405180830381865afa15801562000129573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200014f919062000267565b604051630f41a04d60e11b81526001600160a01b03848116600483015291925090821690631e83409a906024016020604051808303816000875af11580156200019c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001c2919062000287565b50505050505050620002a1565b6001600160a01b0381168114620001e557600080fd5b50565b600080600060608486031215620001fe57600080fd5b83516200020b81620001cf565b60208501519093506200021e81620001cf565b60408501519092506200023181620001cf565b809150509250925092565b6000602082840312156200024f57600080fd5b815180151581146200026057600080fd5b9392505050565b6000602082840312156200027a57600080fd5b81516200026081620001cf565b6000602082840312156200029a57600080fd5b5051919050565b60805161137d620002d9600039600081816101c70152818161041601528181610487015281816105d70152610624015261137d6000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c8063acdbdda111610076578063d919713f1161005b578063d919713f1461017f578063e2443ad2146101c2578063fda41c101461020157600080fd5b8063acdbdda114610146578063d4f1d4e51461016c57600080fd5b806329593e5a116100a757806329593e5a146100fe578063513388491461011e5780639609fb171461013357600080fd5b806301ffc9a7146100c35780630910b77f146100eb575b600080fd5b6100d66100d1366004610c87565b610214565b60405190151581526020015b60405180910390f35b6100d66100f9366004610d0b565b61024b565b61011161010c366004610d0b565b610409565b6040516100e29190610dae565b61013161012c366004610dfc565b610463565b005b610131610141366004610e42565b6105cc565b6100d6610154366004610f22565b5050506001600160a01b039081169116149392505050565b61013161017a366004610fd9565b610619565b6101b461018d36600461105e565b6001602052600090815260409020546001600160a01b03811690600160a01b900460ff1682565b6040516100e292919061108d565b6101e97f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e2565b6100d661020f3660046110c8565b610668565b60006001600160e01b031982166319e733b360e11b148061024557506301ffc9a760e01b6001600160e01b03198316145b92915050565b60008781526001602090815260408220805490916001600160a01b0390911690841461027c576000925050506103fe565b60006102888587611154565b90506000808454600160a01b900460ff1660018111156102aa576102aa611077565b0361032e576040516331a9108f60e11b8152600481018390526001600160a01b03808b169190851690636352211e90602401602060405180830381865afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d9190611172565b6001600160a01b03161490506103a5565b604051627eeac760e11b81526001600160a01b038a81166004830152602482018490526000919085169062fdd58e90604401602060405180830381865afa15801561037d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a1919061118f565b1190505b806103b75760009450505050506103fe565b6000806103c48d8d6108e2565b915091508180156103d55750838114155b156103f35760405163398a3b7d60e21b815260040160405180910390fd5b600196505050505050505b979650505050505050565b60606104136109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461044857600080fd5b61045788888888888888610a4f565b90506103fe6001600055565b813360405163022c977f60e01b8152600481018390526001600160a01b03918216917f0000000000000000000000000000000000000000000000000000000000000000169063022c977f90602401602060405180830381865afa1580156104ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f29190611172565b6001600160a01b03161461050557600080fd5b61051f6001600160a01b0383166380ac58cd60e01b610b81565b1561054c576000838152600160205260408120805460ff60a01b1916600160a01b835b0217905550610590565b6105666001600160a01b038316636cdb3d1360e11b610b81565b156100be576000838152600160208190526040909120805460ff60a01b1916600160a01b83610542565b50600091825260016020526040909120805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b6105d46109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461060957600080fd5b6106136001600055565b50505050565b6106216109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461065657600080fd5b6106606001600055565b505050505050565b60006020821461067a575060006108d8565b60006106868385611154565b60008881526001602090815260409182902080548351601f8b01849004840281018401909452898452939450926001600160a01b031691610782918a908a90819084018382808284376000920182905250888152600188016020526040902080549093506106f6925090506111a8565b80601f0160208091040260200160405190810160405280929190818152602001828054610722906111a8565b801561076f5780601f106107445761010080835404028352916020019161076f565b820191906000526020600020905b81548152906001019060200180831161075257829003601f168201915b5050505050610ba490919063ffffffff16565b61079257600093505050506108d8565b600083815260018084016020526040822001546001600160a01b0316908354600160a01b900460ff1660018111156107cc576107cc611077565b03610861576040516331a9108f60e11b8152600481018590526000906001600160a01b03841690636352211e90602401602060405180830381865afa158015610819573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083d9190611172565b9050816001600160a01b0316816001600160a01b03161415955050505050506108d8565b604051627eeac760e11b81526001600160a01b0382811660048301526024820186905283169062fdd58e90604401602060405180830381865afa1580156108ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d0919061118f565b159450505050505b9695505050505050565b600080805b838110156109e557600360fc1b858583818110610906576109066111e2565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916108061097e5750603960f81b858583818110610950576109506111e2565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916115b156109905760008092509250506109eb565b600060308686848181106109a6576109a66111e2565b6109b79392013560f81c905061120e565b9050806109c584600a611221565b6109cf9190611238565b92505080806109dd9061124b565b9150506108e7565b60019250505b9250929050565b600260005403610a485760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640160405180910390fd5b6002600055565b60606000610a5d8385611154565b60008a815260016020818152604080842085855290920190529020805491925090610a87906111a8565b80601f0160208091040260200160405190810160405280929190818152602001828054610ab3906111a8565b8015610b005780601f10610ad557610100808354040283529160200191610b00565b820191906000526020600020905b815481529060010190602001808311610ae357829003601f168201915b50505060008c815260016020818152604080842088855290920190529020929450610b3091508990508a836112af565b50600089815260016020818152604080842094845293820190529190200180546001600160a01b03871673ffffffffffffffffffffffffffffffffffffffff19909116179055979650505050505050565b6000610b8c83610bba565b8015610b9d5750610b9d8383610bed565b9392505050565b8051602091820120825192909101919091201490565b6000610bcd826301ffc9a760e01b610bed565b80156102455750610be6826001600160e01b0319610bed565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015610c74575060208210155b80156103fe575015159695505050505050565b600060208284031215610c9957600080fd5b81356001600160e01b031981168114610b9d57600080fd5b60008083601f840112610cc357600080fd5b50813567ffffffffffffffff811115610cdb57600080fd5b6020830191508360208285010111156109eb57600080fd5b6001600160a01b0381168114610d0857600080fd5b50565b600080600080600080600060a0888a031215610d2657600080fd5b87359650602088013567ffffffffffffffff80821115610d4557600080fd5b610d518b838c01610cb1565b909850965060408a01359150610d6682610cf3565b909450606089013590610d7882610cf3565b90935060808901359080821115610d8e57600080fd5b50610d9b8a828b01610cb1565b989b979a50959850939692959293505050565b600060208083528351808285015260005b81811015610ddb57858101830151858201604001528201610dbf565b506000604082860101526040601f19601f8301168501019250505092915050565b60008060408385031215610e0f57600080fd5b823591506020830135610e2181610cf3565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610e5857600080fd5b8435610e6381610cf3565b93506020850135610e7381610cf3565b925060408501359150606085013567ffffffffffffffff80821115610e9757600080fd5b818701915087601f830112610eab57600080fd5b813581811115610ebd57610ebd610e2c565b604051601f8201601f19908116603f01168101908382118183101715610ee557610ee5610e2c565b816040528281528a6020848701011115610efe57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060008060008060008060c0898b031215610f3e57600080fd5b88359750602089013567ffffffffffffffff80821115610f5d57600080fd5b610f698c838d01610cb1565b909950975060408b01359150610f7e82610cf3565b90955060608a013590610f9082610cf3565b90945060808a013590610fa282610cf3565b90935060a08a01359080821115610fb857600080fd5b50610fc58b828c01610cb1565b999c989b5096995094979396929594505050565b60008060008060008060a08789031215610ff257600080fd5b86359550602087013567ffffffffffffffff81111561101057600080fd5b61101c89828a01610cb1565b909650945050604087013561103081610cf3565b9250606087013561104081610cf3565b9150608087013561105081610cf3565b809150509295509295509295565b60006020828403121561107057600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b038316815260408101600283106110bb57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b600080600080600080608087890312156110e157600080fd5b86356110ec81610cf3565b955060208701359450604087013567ffffffffffffffff8082111561111057600080fd5b61111c8a838b01610cb1565b9096509450606089013591508082111561113557600080fd5b5061114289828a01610cb1565b979a9699509497509295939492505050565b8035602083101561024557600019602084900360031b1b1692915050565b60006020828403121561118457600080fd5b8151610b9d81610cf3565b6000602082840312156111a157600080fd5b5051919050565b600181811c908216806111bc57607f821691505b6020821081036111dc57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115610245576102456111f8565b8082028115828204841417610245576102456111f8565b80820180821115610245576102456111f8565b60006001820161125d5761125d6111f8565b5060010190565b601f8211156112aa57600081815260208120601f850160051c8101602086101561128b5750805b601f850160051c820191505b8181101561066057828155600101611297565b505050565b67ffffffffffffffff8311156112c7576112c7610e2c565b6112db836112d583546111a8565b83611264565b6000601f84116001811461130f57600085156112f75750838201355b600019600387901b1c1916600186901b178355611369565b600083815260209020601f19861690835b828110156113405786850135825560209485019460019092019101611320565b508682101561135d5760001960f88860031b161c19848701351681555b505060018560011b0183555b505050505056fea164736f6c6343000811000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100be5760003560e01c8063acdbdda111610076578063d919713f1161005b578063d919713f1461017f578063e2443ad2146101c2578063fda41c101461020157600080fd5b8063acdbdda114610146578063d4f1d4e51461016c57600080fd5b806329593e5a116100a757806329593e5a146100fe578063513388491461011e5780639609fb171461013357600080fd5b806301ffc9a7146100c35780630910b77f146100eb575b600080fd5b6100d66100d1366004610c87565b610214565b60405190151581526020015b60405180910390f35b6100d66100f9366004610d0b565b61024b565b61011161010c366004610d0b565b610409565b6040516100e29190610dae565b61013161012c366004610dfc565b610463565b005b610131610141366004610e42565b6105cc565b6100d6610154366004610f22565b5050506001600160a01b039081169116149392505050565b61013161017a366004610fd9565b610619565b6101b461018d36600461105e565b6001602052600090815260409020546001600160a01b03811690600160a01b900460ff1682565b6040516100e292919061108d565b6101e97f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100e2565b6100d661020f3660046110c8565b610668565b60006001600160e01b031982166319e733b360e11b148061024557506301ffc9a760e01b6001600160e01b03198316145b92915050565b60008781526001602090815260408220805490916001600160a01b0390911690841461027c576000925050506103fe565b60006102888587611154565b90506000808454600160a01b900460ff1660018111156102aa576102aa611077565b0361032e576040516331a9108f60e11b8152600481018390526001600160a01b03808b169190851690636352211e90602401602060405180830381865afa1580156102f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031d9190611172565b6001600160a01b03161490506103a5565b604051627eeac760e11b81526001600160a01b038a81166004830152602482018490526000919085169062fdd58e90604401602060405180830381865afa15801561037d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a1919061118f565b1190505b806103b75760009450505050506103fe565b6000806103c48d8d6108e2565b915091508180156103d55750838114155b156103f35760405163398a3b7d60e21b815260040160405180910390fd5b600196505050505050505b979650505050505050565b60606104136109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461044857600080fd5b61045788888888888888610a4f565b90506103fe6001600055565b813360405163022c977f60e01b8152600481018390526001600160a01b03918216917f0000000000000000000000000000000000000000000000000000000000000000169063022c977f90602401602060405180830381865afa1580156104ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f29190611172565b6001600160a01b03161461050557600080fd5b61051f6001600160a01b0383166380ac58cd60e01b610b81565b1561054c576000838152600160205260408120805460ff60a01b1916600160a01b835b0217905550610590565b6105666001600160a01b038316636cdb3d1360e11b610b81565b156100be576000838152600160208190526040909120805460ff60a01b1916600160a01b83610542565b50600091825260016020526040909120805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b6105d46109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461060957600080fd5b6106136001600055565b50505050565b6106216109f2565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461065657600080fd5b6106606001600055565b505050505050565b60006020821461067a575060006108d8565b60006106868385611154565b60008881526001602090815260409182902080548351601f8b01849004840281018401909452898452939450926001600160a01b031691610782918a908a90819084018382808284376000920182905250888152600188016020526040902080549093506106f6925090506111a8565b80601f0160208091040260200160405190810160405280929190818152602001828054610722906111a8565b801561076f5780601f106107445761010080835404028352916020019161076f565b820191906000526020600020905b81548152906001019060200180831161075257829003601f168201915b5050505050610ba490919063ffffffff16565b61079257600093505050506108d8565b600083815260018084016020526040822001546001600160a01b0316908354600160a01b900460ff1660018111156107cc576107cc611077565b03610861576040516331a9108f60e11b8152600481018590526000906001600160a01b03841690636352211e90602401602060405180830381865afa158015610819573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083d9190611172565b9050816001600160a01b0316816001600160a01b03161415955050505050506108d8565b604051627eeac760e11b81526001600160a01b0382811660048301526024820186905283169062fdd58e90604401602060405180830381865afa1580156108ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d0919061118f565b159450505050505b9695505050505050565b600080805b838110156109e557600360fc1b858583818110610906576109066111e2565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916108061097e5750603960f81b858583818110610950576109506111e2565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916115b156109905760008092509250506109eb565b600060308686848181106109a6576109a66111e2565b6109b79392013560f81c905061120e565b9050806109c584600a611221565b6109cf9190611238565b92505080806109dd9061124b565b9150506108e7565b60019250505b9250929050565b600260005403610a485760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640160405180910390fd5b6002600055565b60606000610a5d8385611154565b60008a815260016020818152604080842085855290920190529020805491925090610a87906111a8565b80601f0160208091040260200160405190810160405280929190818152602001828054610ab3906111a8565b8015610b005780601f10610ad557610100808354040283529160200191610b00565b820191906000526020600020905b815481529060010190602001808311610ae357829003601f168201915b50505060008c815260016020818152604080842088855290920190529020929450610b3091508990508a836112af565b50600089815260016020818152604080842094845293820190529190200180546001600160a01b03871673ffffffffffffffffffffffffffffffffffffffff19909116179055979650505050505050565b6000610b8c83610bba565b8015610b9d5750610b9d8383610bed565b9392505050565b8051602091820120825192909101919091201490565b6000610bcd826301ffc9a760e01b610bed565b80156102455750610be6826001600160e01b0319610bed565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015610c74575060208210155b80156103fe575015159695505050505050565b600060208284031215610c9957600080fd5b81356001600160e01b031981168114610b9d57600080fd5b60008083601f840112610cc357600080fd5b50813567ffffffffffffffff811115610cdb57600080fd5b6020830191508360208285010111156109eb57600080fd5b6001600160a01b0381168114610d0857600080fd5b50565b600080600080600080600060a0888a031215610d2657600080fd5b87359650602088013567ffffffffffffffff80821115610d4557600080fd5b610d518b838c01610cb1565b909850965060408a01359150610d6682610cf3565b909450606089013590610d7882610cf3565b90935060808901359080821115610d8e57600080fd5b50610d9b8a828b01610cb1565b989b979a50959850939692959293505050565b600060208083528351808285015260005b81811015610ddb57858101830151858201604001528201610dbf565b506000604082860101526040601f19601f8301168501019250505092915050565b60008060408385031215610e0f57600080fd5b823591506020830135610e2181610cf3565b809150509250929050565b634e487b7160e01b600052604160045260246000fd5b60008060008060808587031215610e5857600080fd5b8435610e6381610cf3565b93506020850135610e7381610cf3565b925060408501359150606085013567ffffffffffffffff80821115610e9757600080fd5b818701915087601f830112610eab57600080fd5b813581811115610ebd57610ebd610e2c565b604051601f8201601f19908116603f01168101908382118183101715610ee557610ee5610e2c565b816040528281528a6020848701011115610efe57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b60008060008060008060008060c0898b031215610f3e57600080fd5b88359750602089013567ffffffffffffffff80821115610f5d57600080fd5b610f698c838d01610cb1565b909950975060408b01359150610f7e82610cf3565b90955060608a013590610f9082610cf3565b90945060808a013590610fa282610cf3565b90935060a08a01359080821115610fb857600080fd5b50610fc58b828c01610cb1565b999c989b5096995094979396929594505050565b60008060008060008060a08789031215610ff257600080fd5b86359550602087013567ffffffffffffffff81111561101057600080fd5b61101c89828a01610cb1565b909650945050604087013561103081610cf3565b9250606087013561104081610cf3565b9150608087013561105081610cf3565b809150509295509295509295565b60006020828403121561107057600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b038316815260408101600283106110bb57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b600080600080600080608087890312156110e157600080fd5b86356110ec81610cf3565b955060208701359450604087013567ffffffffffffffff8082111561111057600080fd5b61111c8a838b01610cb1565b9096509450606089013591508082111561113557600080fd5b5061114289828a01610cb1565b979a9699509497509295939492505050565b8035602083101561024557600019602084900360031b1b1692915050565b60006020828403121561118457600080fd5b8151610b9d81610cf3565b6000602082840312156111a157600080fd5b5051919050565b600181811c908216806111bc57607f821691505b6020821081036111dc57634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b81810381811115610245576102456111f8565b8082028115828204841417610245576102456111f8565b80820180821115610245576102456111f8565b60006001820161125d5761125d6111f8565b5060010190565b601f8211156112aa57600081815260208120601f850160051c8101602086101561128b5750805b601f850160051c820191505b8181101561066057828155600101611297565b505050565b67ffffffffffffffff8311156112c7576112c7610e2c565b6112db836112d583546111a8565b83611264565b6000601f84116001811461130f57600085156112f75750838201355b600019600387901b1c1916600186901b178355611369565b600083815260209020601f19861690835b828110156113405786850135825560209485019460019092019101611320565b508682101561135d5760001960f88860031b161c19848701351681555b505060018560011b0183555b505050505056fea164736f6c6343000811000a",
  "libraries": {
    "ERC165Checker": "0x7EB821Aa0cA01198A9EC28ee9f5d7491508233e4",
    "StringParsing": "0xe0c9b7B08a9A409eA6537c8fb307CE6758CfEd16",
    "Strings": "0x572CbB4dbd1f3bB4E23Cc3d8F4460B3E6d871826",
    "NameEncoder": "0x2b1D7EE297A345fF0C57B3c3B0F34b59951756b1",
    "ENSNameHash": "0x969254c8EC87eF59BeB6F6eA928f1A00bb649Ecc",
    "ENSByteUtils": "0x4A44B0Af7483Eb232F606418Aa099ad453F95A02",
    "ENSParentName": "0xeE1CcD12e954bFD828EEb4Ca3B76cfE4cbc42C76"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "canClaimTag(bytes32,string,address,address,bytes)": {
        "details": "Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`. The caller must own the given TokenID.",
        "params": {
          "claimant": "The address attempting to claim the tag (not necessarily the address that will receive it)",
          "extraClaimArgs": "[Optional] Any guild-specific additional arguments required",
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "recipient": "The address that would receive the tag",
          "tag": "The tag being claimed (e.g. 'foo' for foo.my-guild.eth)"
        }
      },
      "canRevokeTag(address,bytes32,string,bytes)": {
        "params": {
          "extraRevokeArgs": "Any additional arguments necessary for assessing whether a tag may be revoked",
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "revokedBy": "The address that would attempt to revoke it",
          "tag": "The tag being revoked (e.g. 'foo' for foo.my-guild.eth)"
        }
      },
      "canTransferTag(bytes32,string,address,address,address,bytes)": {
        "params": {
          "currentOwner": "The address currently owning the given tag",
          "extraTransferArgs": "Any additional arguments necessary for assessing whether a tag may be transferred",
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "newOwner": "The address that would receive the tag",
          "tag": "The tag being revoked (e.g. 'foo' for foo.my-guild.eth)",
          "transferredBy": "The address initiating the transfer. May be different than the currentOwner, such as an admin or a marketplace contract"
        }
      },
      "onTagClaimed(bytes32,string,address,address,bytes)": {
        "details": "protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.",
        "params": {
          "claimant": "The address that claimed the tag (not necessarily the address that received it)",
          "extraClaimArgs": "[Optional] Any guild-specific additional arguments required",
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "recipient": "The address that received receive the tag",
          "tag": "The tag being claimed (e.g. 'foo' for foo.my-guild.eth)"
        },
        "returns": {
          "tagToRevoke": "Any tag that should be revoked as a consequence of the given tag being claimed. Returns empty string if no tag should be revoked."
        }
      },
      "onTagRevoked(address,address,bytes32,string)": {
        "details": "protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.",
        "params": {
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "revokedBy": "The address that revoked it",
          "revokedFrom": "The address who owned it when it was revoked",
          "tag": "The tag being revoked (e.g. 'foo' for foo.my-guild.eth)"
        }
      },
      "onTagTransferred(bytes32,string,address,address,address)": {
        "details": "protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.",
        "params": {
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "newOwner": "The address that received the tag",
          "prevOwner": "The address that previously owned the tag",
          "tag": "The tag that was transferred",
          "transferredBy": "The address initiating the transfer"
        }
      },
      "setTokenContract(bytes32,address)": {
        "params": {
          "guildEnsNode": "The ENS namehash of the guild's domain",
          "tokenContract": "The ERC721 or ERC1155 collection to use"
        }
      }
    },
    "title": "NFTTagsAuthPolicy",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "canClaimTag(bytes32,string,address,address,bytes)": {
        "notice": "Checks whether a certain address (claimant) may claim a given guild tag that has been revoked or has never been claimed"
      },
      "canRevokeTag(address,bytes32,string,bytes)": {
        "notice": "Checks whether a given guild tag is eligible to be revoked"
      },
      "canTransferTag(bytes32,string,address,address,address,bytes)": {
        "notice": "Checks whether a tag can be transferred. Implementations may trust that `currentOwner` is the owner of the given tag."
      },
      "onTagRevoked(address,address,bytes32,string)": {
        "notice": "Called by ENSGuilds once a tag has been revoked."
      },
      "onTagTransferred(bytes32,string,address,address,address)": {
        "notice": "Called by ENSGuilds once a tag has been transferred"
      },
      "setTokenContract(bytes32,address)": {
        "notice": "Registers the specific NFT collection that a user must be a member of to mint a guild tag"
      }
    },
    "notice": "A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being revoked once the second is minted, regardless of whether ownership of that TokenID has changed. A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1477,
        "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 11060,
        "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
        "label": "guilds",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(GuildInfo)11055_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_enum(TokenStandard)11039": {
        "encoding": "inplace",
        "label": "enum NFTTagsAuthPolicy.TokenStandard",
        "numberOfBytes": "1"
      },
      "t_mapping(t_bytes32,t_struct(GuildInfo)11055_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct NFTTagsAuthPolicy.GuildInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(GuildInfo)11055_storage"
      },
      "t_mapping(t_uint256,t_struct(TagClaim)11044_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct NFTTagsAuthPolicy.TagClaim)",
        "numberOfBytes": "32",
        "value": "t_struct(TagClaim)11044_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(GuildInfo)11055_storage": {
        "encoding": "inplace",
        "label": "struct NFTTagsAuthPolicy.GuildInfo",
        "members": [
          {
            "astId": 11046,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tokenContract",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11049,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tokenStandard",
            "offset": 20,
            "slot": "0",
            "type": "t_enum(TokenStandard)11039"
          },
          {
            "astId": 11054,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tagClaims",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(TagClaim)11044_storage)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TagClaim)11044_storage": {
        "encoding": "inplace",
        "label": "struct NFTTagsAuthPolicy.TagClaim",
        "members": [
          {
            "astId": 11041,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tag",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 11043,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "claimedBy",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}