{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "import \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true if the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IAddrResolver.sol\";\nimport \"./IAddressResolver.sol\";\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    ResolverBase\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(\n        bytes32 node,\n        address a\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(\n        bytes32 node\n    ) public view virtual override returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\n    }\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual override returns (bytes memory) {\n        return versionable_addresses[recordVersions[node]][node][coinType];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(\n        bytes memory b\n    ) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract ExtendedResolver {\n    function resolve(\n        bytes memory /* name */,\n        bytes memory data\n    ) external view returns (bytes memory) {\n        (bool success, bytes memory result) = address(this).staticcall(data);\n        if (success) {\n            return result;\n        } else {\n            // Revert with the reason provided by the call\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external virtual authorised(node) {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view virtual override returns (string memory) {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(ITextResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./profiles/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165, IVersionableResolver {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IVersionableResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\n\ncontract ReverseClaimer {\n    bytes32 constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    constructor(ENS ens, address claimant) {\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        reverseRegistrar.claim(claimant);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {BytesUtils} from \"../wrapper/BytesUtils.sol\";\n\nlibrary NameEncoder {\n    using BytesUtils for bytes;\n\n    function dnsEncodeName(\n        string memory name\n    ) internal pure returns (bytes memory dnsName, bytes32 node) {\n        uint8 labelLength = 0;\n        bytes memory bytesName = bytes(name);\n        uint256 length = bytesName.length;\n        dnsName = new bytes(length + 2);\n        node = 0;\n        if (length == 0) {\n            dnsName[0] = 0;\n            return (dnsName, node);\n        }\n\n        // use unchecked to save gas since we check for an underflow\n        // and we check for the length before the loop\n        unchecked {\n            for (uint256 i = length - 1; i >= 0; i--) {\n                if (bytesName[i] == \".\") {\n                    dnsName[i + 1] = bytes1(labelLength);\n                    node = keccak256(\n                        abi.encodePacked(\n                            node,\n                            bytesName.keccak(i + 1, labelLength)\n                        )\n                    );\n                    labelLength = 0;\n                } else {\n                    labelLength += 1;\n                    dnsName[i + 1] = bytesName[i];\n                }\n                if (i == 0) {\n                    break;\n                }\n            }\n        }\n\n        node = keccak256(\n            abi.encodePacked(node, bytesName.keccak(0, labelLength))\n        );\n\n        dnsName[0] = bytes1(labelLength);\n        return (dnsName, node);\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/BytesUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nlibrary BytesUtils {\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /**\n     * @dev Returns the ENS namehash of a DNS-encoded name.\n     * @param self The DNS-encoded name to hash.\n     * @param offset The offset at which to start hashing.\n     * @return The namehash of the name.\n     */\n    function namehash(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\n        if (labelhash == bytes32(0)) {\n            require(offset == self.length - 1, \"namehash: Junk at end of name\");\n            return bytes32(0);\n        }\n        return\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\n    }\n\n    /**\n     * @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\n     * @param self The byte string to read a label from.\n     * @param idx The index to read a label at.\n     * @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\n     * @return newIdx The index of the start of the next label.\n     */\n    function readLabel(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\n        require(idx < self.length, \"readLabel: Index out of bounds\");\n        uint256 len = uint256(uint8(self[idx]));\n        if (len > 0) {\n            labelhash = keccak(self, idx + 1, len);\n        } else {\n            labelhash = bytes32(0);\n        }\n        newIdx = idx + len + 1;\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant CANNOT_APPROVE = 64;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\nimport \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../interfaces/IERC4906.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n\n        emit MetadataUpdate(tokenId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/ensGuilds/ENSGuilds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { INameWrapper } from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport { ERC1155Holder } from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport { ERC1155Receiver } from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport { ERC1155 } from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { IFeePolicy } from \"../feePolicies/IFeePolicy.sol\";\nimport { ITagsAuthPolicy } from \"../tagsAuthPolicies/ITagsAuthPolicy.sol\";\nimport { ENSNamehash } from \"../libraries/ENSNamehash.sol\";\nimport { IENSGuilds } from \"./interfaces/IENSGuilds.sol\";\nimport { GuildTagTokens } from \"./mixins/GuildTagTokens.sol\";\nimport { ENSGuildsHumanized } from \"./mixins/ENSGuildsHumanized.sol\";\nimport { GuildsResolver } from \"./GuildsResolver.sol\";\n\ncontract ENSGuilds is IENSGuilds, ENSGuildsHumanized, GuildTagTokens, ERC1155Holder, ReentrancyGuard, ReverseClaimer {\n    struct GuildInfo {\n        address admin;\n        IFeePolicy feePolicy;\n        ITagsAuthPolicy tagsAuthPolicy;\n        address originalResolver;\n        bool active;\n        bool deregistered;\n        bool usesNameWrapper;\n    }\n\n    using ERC165Checker for address;\n    using ENSNamehash for bytes;\n\n    /** State */\n    ENS private immutable _ensRegistry;\n    INameWrapper private immutable _nameWrapper;\n    GuildsResolver private immutable _guildsResolver;\n    mapping(bytes32 => GuildInfo) public guilds;\n\n    /** Errors */\n    error AlreadyRegistered();\n    error ENSGuildsIsNotRegisteredOperator();\n    error NotDomainOwner();\n    error InvalidPolicy(address);\n    error GuildNotActive();\n    error ClaimUnauthorized();\n    error RevokeUnauthorized();\n    error TransferUnauthorized();\n    error GuildAdminOnly();\n    error TagAlreadyClaimed();\n    error FeeError();\n\n    modifier onlyGuildAdmin(bytes32 guildHash) {\n        if (guilds[guildHash].admin != _msgSender()) {\n            revert GuildAdminOnly();\n        }\n        _;\n    }\n\n    modifier requireGuildRegistered(bytes32 guildEnsNode) {\n        if (guilds[guildEnsNode].deregistered) {\n            revert GuildNotActive();\n        }\n        _;\n    }\n\n    modifier requireGuildActive(bytes32 guildEnsNode) {\n        if (!guilds[guildEnsNode].active || guilds[guildEnsNode].deregistered) {\n            revert GuildNotActive();\n        }\n        _;\n    }\n\n    constructor(\n        string memory defaultTokenMetadataUri,\n        ENS ensRegistry,\n        INameWrapper nameWrapper,\n        GuildsResolver guildsResolver,\n        address reverseRecordOwner\n    ) ERC1155(defaultTokenMetadataUri) ReverseClaimer(ensRegistry, reverseRecordOwner) {\n        _ensRegistry = ensRegistry;\n        _nameWrapper = nameWrapper;\n        _guildsResolver = guildsResolver;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(GuildTagTokens, ERC1155Receiver, IERC165) returns (bool) {\n        return\n            interfaceId == type(IENSGuilds).interfaceId ||\n            GuildTagTokens.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId) ||\n            ERC165.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function registerGuild(\n        string calldata guildName,\n        address admin,\n        address feePolicy,\n        address tagsAuthPolicy\n    ) public override(IENSGuilds) {\n        bytes32 ensNode = bytes(guildName).namehash();\n\n        // Determine whether this name is using the ENS NameWrapper\n        address nodeOwner = _ensRegistry.owner(ensNode);\n        bool usesNameWrapper = false;\n        if (nodeOwner == address(_nameWrapper)) {\n            nodeOwner = _nameWrapper.ownerOf(uint256(ensNode));\n            usesNameWrapper = true;\n        }\n\n        // Check caller is owner of domain\n        if (nodeOwner != _msgSender()) {\n            revert NotDomainOwner();\n        }\n\n        // Check guild not yet registered\n        if (address(guilds[ensNode].feePolicy) != address(0)) {\n            revert AlreadyRegistered();\n        }\n\n        // Check ENSGuilds contract has been approved to edit the ENS registry on behalf of the caller\n        if (usesNameWrapper && !_nameWrapper.isApprovedForAll(_msgSender(), address(this))) {\n            revert ENSGuildsIsNotRegisteredOperator();\n        }\n        if (!usesNameWrapper && !_ensRegistry.isApprovedForAll(_msgSender(), address(this))) {\n            revert ENSGuildsIsNotRegisteredOperator();\n        }\n\n        // Check for valid fee/tagsAuth policies\n        if (!feePolicy.supportsInterface(type(IFeePolicy).interfaceId)) {\n            revert InvalidPolicy(feePolicy);\n        }\n        if (!tagsAuthPolicy.supportsInterface(type(ITagsAuthPolicy).interfaceId)) {\n            revert InvalidPolicy(tagsAuthPolicy);\n        }\n\n        // Store the config for this Guild\n        address originalResolver = _ensRegistry.resolver(ensNode);\n        guilds[ensNode] = GuildInfo({\n            admin: admin,\n            feePolicy: IFeePolicy(feePolicy),\n            tagsAuthPolicy: ITagsAuthPolicy(tagsAuthPolicy),\n            originalResolver: originalResolver,\n            active: true,\n            deregistered: false,\n            usesNameWrapper: usesNameWrapper\n        });\n\n        // Set GuildsResolver as the resolver for the Guild's ENS name\n        _guildsResolver.setPassthroughTarget(ensNode, originalResolver);\n        _setResolverForGuild(ensNode, address(_guildsResolver));\n        _guildsResolver.onGuildRegistered(guildName);\n\n        // Done\n        emit Registered(ensNode);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function deregisterGuild(\n        bytes32 ensNode\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(ensNode) requireGuildRegistered(ensNode) {\n        // wipe all the ENS records so that this guild may be re-registered later with a clean state\n        _guildsResolver.clearEnsRecordsForGuild(ensNode);\n\n        // un-set ENSGuilds as the resolver for the guild's ENS name\n        address originalResolver = guilds[ensNode].originalResolver;\n        _setResolverForGuild(ensNode, address(originalResolver));\n\n        // clear out internal state\n        guilds[ensNode] = GuildInfo({\n            deregistered: true,\n            admin: address(0),\n            feePolicy: IFeePolicy(address(0)),\n            tagsAuthPolicy: ITagsAuthPolicy(address(0)),\n            originalResolver: address(0),\n            active: false,\n            usesNameWrapper: false\n        });\n        emit Deregistered(ensNode);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function claimGuildTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) public payable override(ENSGuildsHumanized, IENSGuilds) nonReentrant requireGuildActive(guildEnsNode) {\n        bytes32 tagHash = keccak256(bytes(tag));\n\n        // check tag not already registered\n        bytes32 tagEnsNode = keccak256(abi.encodePacked(guildEnsNode, tagHash));\n        if (_ensRegistry.owner(tagEnsNode) != address(0)) {\n            // this is a pre-existing sub-name already registered outside of the Guilds context\n            revert TagAlreadyClaimed();\n        }\n        if (tagOwner(guildEnsNode, tagHash) != address(0)) {\n            // already registered as a Guild tag\n            revert TagAlreadyClaimed();\n        }\n\n        // check caller is authorized to claim tag\n        ITagsAuthPolicy auth = guilds[guildEnsNode].tagsAuthPolicy;\n        if (!auth.canClaimTag(guildEnsNode, tag, _msgSender(), recipient, extraClaimArgs)) {\n            revert ClaimUnauthorized();\n        }\n\n        // fees\n        _handleClaimFee(guildEnsNode, tag, extraClaimArgs);\n\n        // NFT mint\n        _mintNewGuildToken(guildEnsNode, recipient);\n\n        // inform auth contract that tag was claimed, then revoke an existing tag if instructed\n        string memory tagToRevoke = auth.onTagClaimed(guildEnsNode, tag, _msgSender(), recipient, extraClaimArgs);\n        if (bytes(tagToRevoke).length != 0) {\n            _revokeTag(guildEnsNode, tagToRevoke);\n        }\n\n        // Set forward record in ENS resolver\n        _guildsResolver.setEnsForwardRecord(guildEnsNode, tag, recipient);\n\n        emit TagClaimed(guildEnsNode, tagHash, recipient);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function claimGuildTagsBatch(\n        bytes32 guildEnsNode,\n        string[] calldata tags,\n        address[] calldata recipients,\n        bytes[] calldata extraClaimArgs\n    ) external payable override {\n        for (uint256 i = 0; i < tags.length; i++) {\n            claimGuildTag(guildEnsNode, tags[i], recipients[i], extraClaimArgs[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function transferGuildTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraTransferArgs\n    ) public override(ENSGuildsHumanized, IENSGuilds) nonReentrant requireGuildActive(guildEnsNode) {\n        bytes32 tagHash = keccak256(bytes(tag));\n        address currentOwner = tagOwner(guildEnsNode, tagHash);\n\n        // check that tag exists\n        if (currentOwner == address(0)) {\n            revert TransferUnauthorized();\n        }\n\n        // transfer authorized?\n        ITagsAuthPolicy auth = guilds[guildEnsNode].tagsAuthPolicy;\n        if (!auth.canTransferTag(guildEnsNode, tag, _msgSender(), currentOwner, recipient, extraTransferArgs)) {\n            revert TransferUnauthorized();\n        }\n\n        // NFT transfer\n        _transferGuildToken(guildEnsNode, currentOwner, recipient);\n\n        // Update forward record in ENS resolver\n        _guildsResolver.setEnsForwardRecord(guildEnsNode, tag, recipient);\n\n        // Inform auth contract that tag was transferred\n        auth.onTagTransferred(guildEnsNode, tag, _msgSender(), currentOwner, recipient);\n\n        emit TagTransferred(guildEnsNode, tagHash, currentOwner, recipient);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function guildAdmin(bytes32 guildHash) public view override(ENSGuildsHumanized, IENSGuilds) returns (address) {\n        return guilds[guildHash].admin;\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function revokeGuildTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        bytes calldata extraData\n    ) public override(ENSGuildsHumanized, IENSGuilds) nonReentrant requireGuildRegistered(guildEnsNode) {\n        GuildInfo storage guild = guilds[guildEnsNode];\n\n        // revoke authorized?\n        ITagsAuthPolicy auth = guild.tagsAuthPolicy;\n        if (!auth.canRevokeTag(_msgSender(), guildEnsNode, tag, extraData)) {\n            revert RevokeUnauthorized();\n        }\n\n        _revokeTag(guildEnsNode, tag);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function revokeGuildTagsBatch(\n        bytes32 guildHash,\n        string[] calldata tags,\n        bytes[] calldata extraData\n    ) external override {\n        for (uint256 i = 0; i < tags.length; i++) {\n            revokeGuildTag(guildHash, tags[i], extraData[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function updateGuildFeePolicy(\n        bytes32 guildEnsNode,\n        address feePolicy\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        if (!feePolicy.supportsInterface(type(IFeePolicy).interfaceId)) {\n            revert InvalidPolicy(feePolicy);\n        }\n        guilds[guildEnsNode].feePolicy = IFeePolicy(feePolicy);\n        emit FeePolicyUpdated(guildEnsNode, feePolicy);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function updateGuildTagsAuthPolicy(\n        bytes32 guildEnsNode,\n        address tagsAuthPolicy\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        if (!tagsAuthPolicy.supportsInterface(type(ITagsAuthPolicy).interfaceId)) {\n            revert InvalidPolicy(tagsAuthPolicy);\n        }\n        guilds[guildEnsNode].tagsAuthPolicy = ITagsAuthPolicy(tagsAuthPolicy);\n        emit TagsAuthPolicyUpdated(guildEnsNode, tagsAuthPolicy);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function transferGuildAdmin(\n        bytes32 guildEnsNode,\n        address newAdmin\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        guilds[guildEnsNode].admin = newAdmin;\n        emit AdminTransferred(guildEnsNode, newAdmin);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function setGuildTokenUri(\n        bytes32 guildEnsNode,\n        string calldata uri\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        _setGuildTokenURI(guildEnsNode, uri);\n        emit TokenUriSet(guildEnsNode, uri);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function setGuildActive(\n        bytes32 guildEnsNode,\n        bool active\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        guilds[guildEnsNode].active = active;\n        emit SetActive(guildEnsNode, active);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function tagOwner(\n        bytes32 guildEnsNode,\n        bytes32 tagHash\n    ) public view override(ENSGuildsHumanized, IENSGuilds) returns (address) {\n        return _guildsResolver.getTagOwner(guildEnsNode, tagHash);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function setFallbackResolver(\n        bytes32 guildEnsNode,\n        address fallbackResolver\n    )\n        public\n        override(ENSGuildsHumanized, IENSGuilds)\n        onlyGuildAdmin(guildEnsNode)\n        requireGuildRegistered(guildEnsNode)\n    {\n        _guildsResolver.setPassthroughTarget(guildEnsNode, fallbackResolver);\n    }\n\n    function _revokeTag(bytes32 guildEnsNode, string memory tag) private {\n        bytes32 tagHash = keccak256(bytes(tag));\n        address _tagOwner = tagOwner(guildEnsNode, tagHash);\n\n        // check that tag exists\n        if (_tagOwner == address(0)) {\n            revert RevokeUnauthorized();\n        }\n\n        // clear the ENS record for the tag\n        _guildsResolver.setEnsForwardRecord(guildEnsNode, tag, address(0));\n\n        // clear the token ownership for the tag\n        _burnGuildToken(guildEnsNode, _tagOwner);\n\n        // inform the auth policy of the revocation\n        ITagsAuthPolicy auth = guilds[guildEnsNode].tagsAuthPolicy;\n        if (address(auth) != address(0)) {\n            auth.onTagRevoked(_msgSender(), _tagOwner, guildEnsNode, tag);\n        }\n\n        emit TagRevoked(guildEnsNode, tagHash);\n    }\n\n    function _handleClaimFee(bytes32 guildEnsNode, string calldata tag, bytes calldata extraClaimArgs) internal {\n        (address feeToken, uint256 fee, address feePaidTo) = guilds[guildEnsNode].feePolicy.tagClaimFee(\n            guildEnsNode,\n            tag,\n            _msgSender(),\n            extraClaimArgs\n        );\n        if (fee != 0) {\n            if (feeToken == address(0)) {\n                if (msg.value != fee) {\n                    revert FeeError();\n                }\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool sent, ) = feePaidTo.call{ value: msg.value }(\"\");\n                if (!sent) revert FeeError();\n            } else {\n                try IERC20(feeToken).transferFrom(_msgSender(), feePaidTo, fee) returns (bool sent) {\n                    if (!sent) revert FeeError();\n                } catch {\n                    revert FeeError();\n                }\n            }\n        }\n    }\n\n    function _setResolverForGuild(bytes32 guildEnsNode, address resolver) internal {\n        if (guilds[guildEnsNode].usesNameWrapper) {\n            _nameWrapper.setResolver(guildEnsNode, resolver);\n        } else {\n            _ensRegistry.setResolver(guildEnsNode, resolver);\n        }\n    }\n}\n"
    },
    "contracts/ensGuilds/GuildsResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { NameEncoder } from \"@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol\";\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { INameWrapper } from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\n\nimport { WildcardResolverBase } from \"../ensWildcardResolvers/WildcardResolverBase.sol\";\nimport { IENSGuilds } from \"./interfaces/IENSGuilds.sol\";\n\ncontract GuildsResolver is WildcardResolverBase, ReverseClaimer {\n    using NameEncoder for string;\n\n    IENSGuilds public ensGuilds;\n\n    // guildEnsNode => recordVersion => keccak256(tag) => tagOwner\n    mapping(bytes32 => mapping(uint256 => mapping(bytes32 => address))) private _guildRecords;\n\n    // used to clear all of a Guild's ENS records\n    mapping(bytes32 => uint256) private _guildRecordVersions;\n\n    modifier onlyEnsGuildsContract() {\n        // solhint-disable-next-line reason-string, custom-errors\n        require(_msgSender() == address(ensGuilds));\n        _;\n    }\n\n    constructor(\n        ENS _ensRegistry,\n        INameWrapper _ensNameWrapper,\n        address reverseRecordOwner\n    ) WildcardResolverBase(_ensRegistry, _ensNameWrapper) ReverseClaimer(_ensRegistry, reverseRecordOwner) {\n        return;\n    }\n\n    function initialize(IENSGuilds _ensGuilds) external {\n        // solhint-disable reason-string, custom-errors\n        require(address(ensGuilds) == address(0));\n        require(_ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        // solhint-enable reason-string, custom-errors\n\n        ensGuilds = _ensGuilds;\n    }\n\n    function onGuildRegistered(string calldata guildName) external onlyEnsGuildsContract {\n        // need to keep track of the mapping from the DNS-encoded version\n        // of the guild name to its namehash-encoded version\n        (bytes memory dnsEncodedName, bytes32 ensNode) = guildName.dnsEncodeName();\n        parentEnsNodes[dnsEncodedName] = ensNode;\n    }\n\n    /**\n     * Sets the address associated with a guild tag.\n     * May only be called by descendants of this contract\n     */\n    function setEnsForwardRecord(\n        bytes32 guildEnsNode,\n        string memory tag,\n        address _addr\n    ) external onlyEnsGuildsContract {\n        uint256 version = _guildRecordVersions[guildEnsNode];\n        bytes32 tagHash = keccak256(bytes(tag));\n        _guildRecords[guildEnsNode][version][tagHash] = _addr;\n    }\n\n    function clearEnsRecordsForGuild(bytes32 guildEnsNode) external onlyEnsGuildsContract {\n        _guildRecordVersions[guildEnsNode]++;\n    }\n\n    function setPassthroughTarget(bytes32 guildEnsNode, address resolver) external onlyEnsGuildsContract {\n        _setPassthroughTarget(guildEnsNode, resolver);\n    }\n\n    function getTagOwner(bytes32 guildEnsNode, bytes32 tagHash) public view returns (address) {\n        uint256 version = _guildRecordVersions[guildEnsNode];\n        return _guildRecords[guildEnsNode][version][tagHash];\n    }\n\n    function _resolveWildcardEthAddr(\n        bytes calldata childUtf8Encoded,\n        bytes calldata parentDnsEncoded\n    ) internal view override returns (address) {\n        bytes32 guildEnsNode = parentEnsNodes[parentDnsEncoded];\n        bytes32 tagHash = keccak256(childUtf8Encoded);\n        return getTagOwner(guildEnsNode, tagHash);\n    }\n\n    function _resolveWildcardTextRecord(\n        bytes calldata,\n        bytes calldata,\n        string calldata\n    ) internal pure override returns (string memory) {\n        // ENSGuilds doesn't set text records for Guild tags\n        return \"\";\n    }\n\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\n        return _msgSender() == _nodeOwner(node);\n    }\n}\n"
    },
    "contracts/ensGuilds/interfaces/IENSGuilds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC1155MetadataURI } from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n\ninterface IENSGuilds is IERC1155MetadataURI {\n    /** Events */\n    event Registered(bytes32 indexed guildEnsNode);\n    event Deregistered(bytes32 indexed guildEnsNode);\n    event TagClaimed(bytes32 indexed guildEnsNode, bytes32 indexed tagHash, address recipient);\n    event TagTransferred(bytes32 indexed guildEnsNode, bytes32 indexed tagHash, address from, address to);\n    event TagRevoked(bytes32 indexed guildEnsNode, bytes32 indexed tagHash);\n    event FeePolicyUpdated(bytes32 indexed guildEnsNode, address feePolicy);\n    event TagsAuthPolicyUpdated(bytes32 indexed guildEnsNode, address tagsAuthPolicy);\n    event AdminTransferred(bytes32 indexed guildEnsNode, address newAdmin);\n    event SetActive(bytes32 indexed guildEnsNode, bool active);\n    event TokenUriSet(bytes32 indexed guildEnsNode, string uri);\n\n    /* Functions */\n\n    /**\n     * @notice Registers a new guild from an existing ENS domain.\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \"operator\" for the caller.\n     * @param ensName The guild's full ENS name (e.g. 'my-guild.eth')\n     * @param guildAdmin The address that will administrate this guild\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for minting new tags\n     * within this guild\n     */\n    function registerGuild(\n        string calldata ensName,\n        address guildAdmin,\n        address feePolicy,\n        address tagsAuthPolicy\n    ) external;\n\n    /**\n     * @notice De-registers a registered guild.\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     */\n    function deregisterGuild(bytes32 guildEnsNode) external;\n\n    /**\n     * @notice Claims a guild tag\n     * @param guildEnsNode The namehash of the guild for which the tag should be claimed (e.g. namehash('my-guild.eth'))\n     * @param tag The tag name to claim (e.g. 'foo' for foo.my-guild.eth). Assumes `tag` is already normalized per\n     * ENS Name Processing rules\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function claimGuildTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Transfers an existing guild tag\n     * @param guildEnsNode The namehash of the guild for which the tag should be transferred\n     * (e.g. namehash('my-guild.eth'))\n     * @param tag The tag name to transfer (e.g. 'foo' for foo.my-guild.eth). Assumes `tag` is already normalized per\n     * ENS Name Processing rules\n     * @param recipient The address that will receive this guild tag\n     * @param extraTransferArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function transferGuildTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraTransferArgs\n    ) external;\n\n    /**\n     * @notice Claims multiple tags for a guild at once\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tags Tags to be claimed\n     * @param recipients Recipients of each tag to be claimed\n     * @param extraClaimArgs Per-tag extra arguments required for guild-specific logic, such as authorization.\n     * Must have same length as array of tagHashes, even if each array element is itself empty bytes\n     */\n    function claimGuildTagsBatch(\n        bytes32 guildEnsNode,\n        string[] calldata tags,\n        address[] calldata recipients,\n        bytes[] calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Returns the current owner of the given guild tag.\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\n     */\n    function tagOwner(bytes32 guildEnsNode, bytes32 tagHash) external view returns (address);\n\n    /**\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag to revoke\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTag(bytes32 guildEnsNode, string calldata tag, bytes calldata extraData) external;\n\n    /**\n     * @notice Attempts to revoke multiple guild tags\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tags tags to revoke\n     * @param extraData Additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTagsBatch(bytes32 guildEnsNode, string[] calldata tags, bytes[] calldata extraData) external;\n\n    /**\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     */\n    function updateGuildFeePolicy(bytes32 guildEnsNode, address feePolicy) external;\n\n    /**\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for\n     * minting new tags within this guild\n     */\n    function updateGuildTagsAuthPolicy(bytes32 guildEnsNode, address tagsAuthPolicy) external;\n\n    /**\n     * @notice Sets the metadata URI string for fetching metadata for a guild's tag NFTs.\n     * May only be called by the guild's registered admin.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param uri The ERC1155 metadata URL template\n     */\n    function setGuildTokenUri(bytes32 guildEnsNode, string calldata uri) external;\n\n    /**\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param active The new status\n     */\n    function setGuildActive(bytes32 guildEnsNode, bool active) external;\n\n    /**\n     * @notice Returns the current admin registered for the given guild.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     */\n    function guildAdmin(bytes32 guildEnsNode) external view returns (address);\n\n    /**\n     * @notice Transfers the role of guild admin to the given address.\n     * May only be called by the guild's registered admin.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param newAdmin The new admin\n     */\n    function transferGuildAdmin(bytes32 guildEnsNode, address newAdmin) external;\n\n    /**\n     * @notice Registers a resolver for the guild's root ENS name that will\n     * answer queries about the parent name itself, or any child names that are\n     * not Guild tags\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param fallbackResolver The fallback resolver\n     */\n    function setFallbackResolver(bytes32 guildEnsNode, address fallbackResolver) external;\n}\n"
    },
    "contracts/ensGuilds/interfaces/IENSGuildsHumanized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IENSGuildsHumanized {\n    function claimGuildTag(\n        string calldata guildEnsName,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable;\n\n    function transferGuildTag(\n        string calldata guildEnsName,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraTransferArgs\n    ) external;\n\n    function setFallbackResolver(string calldata guildEnsName, address fallbackResolver) external;\n\n    function tagOwner(string memory guildEnsName, string memory tag) external view returns (address);\n\n    function revokeGuildTag(string calldata guildEnsName, string calldata tag, bytes calldata extraData) external;\n\n    function updateGuildFeePolicy(string calldata guildEnsName, address feePolicy) external;\n\n    function updateGuildTagsAuthPolicy(string calldata guildEnsName, address tagsAuthPolicy) external;\n\n    function setGuildTokenUri(string calldata guildEnsName, string calldata uri) external;\n\n    function setGuildActive(string calldata guildEnsName, bool active) external;\n\n    function guildAdmin(string memory guildEnsName) external view returns (address);\n\n    function transferGuildAdmin(string calldata guildEnsName, address newAdmin) external;\n\n    function deregisterGuild(string calldata guildEnsName) external;\n}\n"
    },
    "contracts/ensGuilds/mixins/ENSGuildsHumanized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IENSGuildsHumanized } from \"../interfaces/IENSGuildsHumanized.sol\";\nimport { ENSNamehash } from \"../../libraries/ENSNamehash.sol\";\n\nabstract contract ENSGuildsHumanized is IENSGuildsHumanized {\n    using ENSNamehash for bytes;\n\n    // Humanized versions\n\n    /**\n     * @notice De-registers a registered guild.\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     */\n    function deregisterGuild(string calldata guildEnsName) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        deregisterGuild(guildEnsNode);\n    }\n\n    /**\n     * @notice Claims a guild tag\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag to claim (e.g. 'foobar')\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function claimGuildTag(\n        string calldata guildEnsName,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        claimGuildTag(guildEnsNode, tag, recipient, extraClaimArgs);\n    }\n\n    function transferGuildTag(\n        string calldata guildEnsName,\n        string calldata tag,\n        address recipient,\n        bytes calldata extraTransferArgs\n    ) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        transferGuildTag(guildEnsNode, tag, recipient, extraTransferArgs);\n    }\n\n    /**\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag to revoke (e.g. 'foobar')\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTag(\n        string calldata guildEnsName,\n        string calldata tag,\n        bytes calldata extraData\n    ) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        revokeGuildTag(guildEnsNode, tag, extraData);\n    }\n\n    /**\n     * @notice Returns the current owner of the given guild tag.\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag (e.g. 'foobar')\n     */\n    function tagOwner(string memory guildEnsName, string memory tag) external view override returns (address) {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        bytes32 tagHash = keccak256(bytes(tag));\n        return tagOwner(guildEnsNode, tagHash);\n    }\n\n    /**\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     */\n    function updateGuildFeePolicy(string calldata guildEnsName, address feePolicy) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        updateGuildFeePolicy(guildEnsNode, feePolicy);\n    }\n\n    /**\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for\n     * minting new tags within this guild\n     */\n    function updateGuildTagsAuthPolicy(string calldata guildEnsName, address tagsAuthPolicy) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        updateGuildTagsAuthPolicy(guildEnsNode, tagsAuthPolicy);\n    }\n\n    /**\n     * @notice Sets the metadata URI template string for fetching metadata for a guild's tag NFTs.\n     * May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param uri The ERC1155 metadata URL template\n     */\n    function setGuildTokenUri(string calldata guildEnsName, string calldata uri) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        setGuildTokenUri(guildEnsNode, uri);\n    }\n\n    /**\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param active The new status\n     */\n    function setGuildActive(string calldata guildEnsName, bool active) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        setGuildActive(guildEnsNode, active);\n    }\n\n    /**\n     * @notice Returns the current admin registered for the given guild.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     */\n    function guildAdmin(string memory guildEnsName) external view override returns (address) {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        return guildAdmin(guildEnsNode);\n    }\n\n    /**\n     * @notice Transfers the role of guild admin to the given address.\n     * May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param newAdmin The new admin\n     */\n    function transferGuildAdmin(string calldata guildEnsName, address newAdmin) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        transferGuildAdmin(guildEnsNode, newAdmin);\n    }\n\n    /**\n     * @notice Registers a resolver for the guild's root ENS name that will\n     * answer queries about the parent name itself, or any child names that are\n     * not Guild tags\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param fallbackResolver The fallback resolver\n     */\n    function setFallbackResolver(string calldata guildEnsName, address fallbackResolver) external override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        setFallbackResolver(guildEnsNode, fallbackResolver);\n    }\n\n    // Original versions\n\n    function deregisterGuild(bytes32) public virtual;\n\n    function claimGuildTag(bytes32, string calldata, address, bytes calldata) public payable virtual;\n\n    function transferGuildTag(bytes32, string calldata, address, bytes calldata) public virtual;\n\n    function revokeGuildTag(bytes32, string calldata, bytes calldata) public virtual;\n\n    function tagOwner(bytes32, bytes32) public view virtual returns (address);\n\n    function updateGuildFeePolicy(bytes32, address) public virtual;\n\n    function updateGuildTagsAuthPolicy(bytes32, address) public virtual;\n\n    function setGuildTokenUri(bytes32, string calldata) public virtual;\n\n    function setGuildActive(bytes32, bool) public virtual;\n\n    function guildAdmin(bytes32) public view virtual returns (address);\n\n    function transferGuildAdmin(bytes32, address) public virtual;\n\n    function setFallbackResolver(bytes32 guildEnsNode, address fallbackResolver) public virtual;\n}\n"
    },
    "contracts/ensGuilds/mixins/GuildTagTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC1155 } from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\nabstract contract GuildTagTokens is ERC1155 {\n    error GuildsTokenTransferNotAllowed();\n\n    struct GuildTokenInfo {\n        string metadataUri;\n    }\n\n    // maps each guild's GuildID (ensNode) to its metadataURI\n    mapping(bytes32 => GuildTokenInfo) private guilds;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155) returns (bool) {\n        return ERC1155.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     * @param tokenId The token whose URI is returned\n     */\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        // return guild-specific URI if exists\n        string storage guildMetadataURI = guilds[bytes32(tokenId)].metadataUri;\n        if (bytes(guildMetadataURI).length != 0) {\n            return guildMetadataURI;\n        }\n\n        // return default URI shared by all guilds\n        return ERC1155.uri(tokenId);\n    }\n\n    function _mintNewGuildToken(bytes32 guildHash, address to) internal {\n        _mint(to, uint256(guildHash), 1, \"\");\n    }\n\n    function _burnGuildToken(bytes32 guildHash, address tagOwner) internal {\n        _burn(tagOwner, uint256(guildHash), 1);\n    }\n\n    function _transferGuildToken(bytes32 guildHash, address from, address to) internal {\n        _safeTransferFrom(from, to, uint256(guildHash), 1, \"\");\n    }\n\n    function _setGuildTokenURI(bytes32 guildHash, string calldata metadataURI) internal {\n        guilds[guildHash].metadataUri = metadataURI;\n    }\n\n    /**\n     * @dev ENSGuilds NFTs are non-transferrable and may only be directly minted and burned\n     * with their corresponding guild tags.\n     */\n    function safeTransferFrom(address, address, uint256, uint256, bytes memory) public virtual override {\n        revert GuildsTokenTransferNotAllowed();\n    }\n}\n"
    },
    "contracts/ensWildcardResolvers/Erc721WildcardResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { NameEncoder } from \"@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol\";\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { INameWrapper } from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { ENSNamehash } from \"../libraries/ENSNamehash.sol\";\nimport { StringParsing } from \"../libraries/StringParsing.sol\";\nimport { WildcardResolverBase } from \"./WildcardResolverBase.sol\";\n\ncontract Erc721WildcardResolver is WildcardResolverBase, ReverseClaimer {\n    using ENSNamehash for bytes;\n    using ERC165Checker for address;\n    using NameEncoder for string;\n    using StringParsing for bytes;\n    using Strings for string;\n    using Strings for address;\n    using Strings for uint256;\n\n    error CallerNotAuthorised();\n    error InvalidTokenContract();\n\n    // dnsEncode(parentName) -> address\n    // ex: key for \"test.eth\" is `0x04746573740365746800`\n    mapping(bytes => IERC721) public tokens;\n\n    // mapping of namehash(parentName) to set of addresses authorized to set records on the parent\n    mapping(bytes32 => mapping(address => bool)) public approvedDelegates;\n\n    constructor(\n        ENS _ensRegistry,\n        INameWrapper _ensNameWrapper,\n        address reverseRecordOwner\n    ) WildcardResolverBase(_ensRegistry, _ensNameWrapper) ReverseClaimer(_ensRegistry, reverseRecordOwner) {\n        return;\n    }\n\n    function setTokenContract(string calldata ensName, address tokenContract, address fallbackResolver) external {\n        // Must have provided valid ERC721 contract\n        if (!tokenContract.supportsInterface(type(IERC721).interfaceId)) {\n            revert InvalidTokenContract();\n        }\n\n        (bytes memory encodedName, bytes32 ensNode) = ensName.dnsEncodeName();\n\n        // Caller must be the name owner or a delegate of the name owner\n        if (!isAuthorised(ensNode)) {\n            revert CallerNotAuthorised();\n        }\n\n        tokens[encodedName] = IERC721(tokenContract);\n        parentEnsNodes[encodedName] = ensNode;\n        _setPassthroughTarget(ensNode, fallbackResolver);\n    }\n\n    function isAuthorised(bytes32 node) internal view virtual override returns (bool) {\n        address owner = _nodeOwner(node);\n        address sender = _msgSender();\n        return sender == owner || isApprovedFor(owner, node, sender);\n    }\n\n    function isApprovedFor(address, bytes32 node, address delegate) public view returns (bool) {\n        return approvedDelegates[node][delegate];\n    }\n\n    function setApprovedFor(bytes32 node, address delegate, bool approved) external {\n        if (_msgSender() != _nodeOwner(node)) {\n            revert CallerNotAuthorised();\n        }\n        approvedDelegates[node][delegate] = approved;\n    }\n\n    function _resolveWildcardEthAddr(\n        bytes calldata childUtf8Encoded,\n        bytes calldata parentDnsEncoded\n    ) internal view virtual override returns (address) {\n        IERC721 tokenContract = tokens[parentDnsEncoded];\n\n        // No NFT contract registered for this address\n        if (address(tokenContract) == address(0)) {\n            return address(0);\n        }\n\n        // Extract tokenId from child name\n        (bool valid, uint256 tokenId) = childUtf8Encoded.parseUint256();\n        if (!valid) {\n            return address(0);\n        }\n\n        // Lookup token owner\n        address tokenOwner;\n        try tokenContract.ownerOf(tokenId) returns (address _tokenOwner) {\n            tokenOwner = _tokenOwner;\n        } catch {\n            tokenOwner = address(0);\n        }\n        return tokenOwner;\n    }\n\n    function _resolveWildcardTextRecord(\n        bytes calldata childUtf8Encoded,\n        bytes calldata parentDnsEncoded,\n        string calldata key\n    ) internal view virtual override returns (string memory) {\n        IERC721 tokenContract = tokens[parentDnsEncoded];\n\n        // No NFT contract registered for this address\n        if (address(tokenContract) == address(0)) {\n            return \"\";\n        }\n\n        // Extract tokenId from child name\n        (bool valid, uint256 tokenId) = childUtf8Encoded.parseUint256();\n        if (!valid) {\n            return \"\";\n        }\n\n        // Don't bother returning anything if this tokenId has never been minted\n        // solhint-disable-next-line no-empty-blocks\n        try tokenContract.ownerOf(tokenId) {} catch {\n            return \"\";\n        }\n\n        if (key.equal(\"avatar\")) {\n            // Standard described here:\n            // https://docs.ens.domains/ens-improvement-proposals/ensip-12-avatar-text-records\n            return string.concat(\"eip155:1/erc721:\", address(tokenContract).toHexString(), \"/\", tokenId.toString());\n        } else if (key.equal(\"url\")) {\n            string memory url;\n            try IERC721Metadata(address(tokenContract)).tokenURI(tokenId) returns (string memory _url) {\n                url = _url;\n            } catch {\n                url = \"\";\n            }\n            return url;\n        }\n\n        // unsupported key\n        return \"\";\n    }\n}\n"
    },
    "contracts/ensWildcardResolvers/IPublicResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IABIResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol\";\nimport { IAddrResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport { IAddressResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\";\nimport { IContentHashResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\";\nimport { IDNSRecordResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSRecordResolver.sol\";\nimport { IDNSZoneResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSZoneResolver.sol\";\nimport { IInterfaceResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol\";\nimport { INameResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\";\nimport { IPubkeyResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol\";\nimport { ITextResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\";\n\ninterface IPublicResolver is\n    IABIResolver,\n    IAddrResolver,\n    IAddressResolver,\n    IContentHashResolver,\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver\n{\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n\n    function setAddr(bytes32 node, address a) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes memory a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDNSRecords(bytes32 node, bytes calldata data) external;\n\n    function setZonehash(bytes32 node, bytes calldata hash) external;\n\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function setName(bytes32 node, string calldata newName) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n}\n"
    },
    "contracts/ensWildcardResolvers/PassthroughResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ResolverBase } from \"@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {\n    IPublicResolver,\n    IABIResolver,\n    IAddrResolver,\n    IAddressResolver,\n    IContentHashResolver,\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver\n} from \"./IPublicResolver.sol\";\n\n/**\n * @dev PassthroughResolver is an ENS Resolver that forwards all calls to a\n * fallback Resolver. A custom resolver may inherit this contract\n * to selectively implement specific record types, deferring all others to the\n * fallback Resolver (usually whatever public Resolver the ENS app set on behalf\n * of the user when a name was registered).\n *\n * The owner of the ENS name must first configure their PublicResolver to approve\n * this contract as an authorized manager on the owner's behalf for the setter\n * methods of PassthroughResolver to work. Note that this delegation is separate\n * from approvals set with the ENS Registry. ENS's public Registry and its public\n * Resolvers each have their own, independent concepts of approved managers.\n */\nabstract contract PassthroughResolver is IPublicResolver, ResolverBase {\n    using ERC165Checker for address;\n\n    mapping(bytes32 => address) private _passthroughTargets;\n\n    function isAuthorised(bytes32) internal view virtual override returns (bool);\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IABIResolver).interfaceId ||\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            interfaceID == type(IContentHashResolver).interfaceId ||\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\n            interfaceID == type(IInterfaceResolver).interfaceId ||\n            interfaceID == type(INameResolver).interfaceId ||\n            interfaceID == type(IPubkeyResolver).interfaceId ||\n            interfaceID == type(ITextResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function getPassthroughTarget(bytes32 node) public view virtual returns (address resolver) {\n        return _passthroughTargets[node];\n    }\n\n    function _setPassthroughTarget(bytes32 node, address target) internal {\n        _passthroughTargets[node] = target;\n    }\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setABI(node, contentType, data);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view virtual override returns (uint256 a, bytes memory b) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IABIResolver).interfaceId)) {\n            return IABIResolver(target).ABI(node, contentTypes);\n        }\n    }\n\n    function setAddr(bytes32 node, address a) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setAddr(node, a);\n    }\n\n    function addr(bytes32 node) public view virtual override returns (address payable result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IAddrResolver).interfaceId)) {\n            return IAddrResolver(target).addr(node);\n        }\n    }\n\n    function setAddr(bytes32 node, uint256 coinType, bytes memory a) public virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setAddr(node, coinType, a);\n    }\n\n    function addr(bytes32 node, uint256 coinType) public view virtual override returns (bytes memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IAddressResolver).interfaceId)) {\n            return IAddressResolver(target).addr(node, coinType);\n        }\n    }\n\n    function setContenthash(bytes32 node, bytes calldata hash) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setContenthash(node, hash);\n    }\n\n    function contenthash(bytes32 node) external view virtual override returns (bytes memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IContentHashResolver).interfaceId)) {\n            return IContentHashResolver(target).contenthash(node);\n        }\n    }\n\n    function setDNSRecords(bytes32 node, bytes calldata data) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setDNSRecords(node, data);\n    }\n\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name, // solhint-disable-line\n        uint16 resource\n    ) public view virtual override returns (bytes memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IDNSRecordResolver).interfaceId)) {\n            return IDNSRecordResolver(target).dnsRecord(node, name, resource);\n        }\n    }\n\n    function setZonehash(bytes32 node, bytes calldata hash) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setZonehash(node, hash);\n    }\n\n    function zonehash(bytes32 node) external view virtual override returns (bytes memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IDNSZoneResolver).interfaceId)) {\n            return IDNSZoneResolver(target).zonehash(node);\n        }\n    }\n\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setInterface(node, interfaceID, implementer);\n    }\n\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view virtual override returns (address result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IInterfaceResolver).interfaceId)) {\n            return IInterfaceResolver(target).interfaceImplementer(node, interfaceID);\n        }\n    }\n\n    function setName(bytes32 node, string calldata newName) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setName(node, newName);\n    }\n\n    function name(bytes32 node) external view virtual override returns (string memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(INameResolver).interfaceId)) {\n            return INameResolver(target).name(node);\n        }\n    }\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setPubkey(node, x, y);\n    }\n\n    function pubkey(bytes32 node) external view virtual override returns (bytes32 x, bytes32 y) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(IPubkeyResolver).interfaceId)) {\n            return IPubkeyResolver(target).pubkey(node);\n        }\n    }\n\n    function setText(bytes32 node, string calldata key, string calldata value) external virtual authorised(node) {\n        IPublicResolver(getPassthroughTarget(node)).setText(node, key, value);\n    }\n\n    function text(bytes32 node, string calldata key) public view virtual override returns (string memory result) {\n        address target = getPassthroughTarget(node);\n        if (target.supportsInterface(type(ITextResolver).interfaceId)) {\n            return ITextResolver(target).text(node, key);\n        }\n    }\n}\n"
    },
    "contracts/ensWildcardResolvers/WildcardResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { INameWrapper } from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\nimport { IExtendedResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport { ENSParentName } from \"../libraries/ENSParentName.sol\";\nimport { ENSByteUtils } from \"../libraries/ENSByteUtils.sol\";\nimport { PassthroughResolver } from \"./PassthroughResolver.sol\";\n\nabstract contract WildcardResolverBase is IExtendedResolver, Context, PassthroughResolver {\n    using ENSByteUtils for address;\n    using ENSByteUtils for bytes;\n    using ENSParentName for bytes;\n    using ERC165Checker for address;\n\n    error RecordTypeNotSupported();\n\n    bytes4 public constant RESOLVER_SIGNATURE__ADDR = bytes4(keccak256(bytes(\"addr(bytes32)\")));\n    bytes4 public constant RESOLVER_SIGNATURE__ADDR_WITH_COINTYPE = bytes4(keccak256(bytes(\"addr(bytes32,uint256)\")));\n    bytes4 public constant RESOLVER_SIGNATURE__TEXT = bytes4(keccak256(bytes(\"text(bytes32,string)\")));\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    ENS public immutable ensRegistry;\n    INameWrapper public immutable ensNameWrapper;\n\n    // dnsEncode(parentName) -> namehash(parentName)\n    // ex: \"test.eth\" would be mapped as\n    // 0x04746573740365746800 -> 0xeb4f647bea6caa36333c816d7b46fdcb05f9466ecacc140ea8c66faf15b3d9f1\n    mapping(bytes => bytes32) internal parentEnsNodes;\n\n    constructor(ENS _ensRegistry, INameWrapper _ensNameWrapper) {\n        ensRegistry = _ensRegistry;\n        ensNameWrapper = _ensNameWrapper;\n    }\n\n    function resolve(\n        bytes calldata dnsEncodedName,\n        bytes calldata resolverCalldata\n    ) public view virtual override returns (bytes memory) {\n        bytes4 resolverSignature = bytes4(resolverCalldata[:4]);\n\n        if (resolverSignature == RESOLVER_SIGNATURE__ADDR) {\n            address ethAddr = _resolveEthAddr(dnsEncodedName, resolverCalldata);\n            return abi.encode(ethAddr);\n        } else if (resolverSignature == RESOLVER_SIGNATURE__ADDR_WITH_COINTYPE) {\n            (, uint256 coinType) = abi.decode(resolverCalldata[4:], (bytes32, uint256));\n            if (coinType == COIN_TYPE_ETH) {\n                address ethAddr = _resolveEthAddr(dnsEncodedName, resolverCalldata);\n                return abi.encode(ethAddr.toBytes());\n            } else {\n                // Unsupported COIN_TYPE\n                bytes memory emptyBytes;\n                return abi.encode(emptyBytes);\n            }\n        } else if (resolverSignature == RESOLVER_SIGNATURE__TEXT) {\n            string calldata key = _parseKeyFromCalldata(resolverCalldata);\n            string memory result = _resolveTextRecord(dnsEncodedName, key, resolverCalldata);\n            return abi.encode(result);\n        }\n\n        revert RecordTypeNotSupported();\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(PassthroughResolver) returns (bool) {\n        return interfaceID == type(IExtendedResolver).interfaceId || PassthroughResolver.supportsInterface(interfaceID);\n    }\n\n    function _resolveWildcardEthAddr(\n        bytes calldata childUtf8Encoded,\n        bytes calldata parentDnsEncoded\n    ) internal view virtual returns (address);\n\n    function _resolveWildcardTextRecord(\n        bytes calldata childUtf8Encoded,\n        bytes calldata parentDnsEncoded,\n        string calldata key\n    ) internal view virtual returns (string memory);\n\n    function _resolveEthAddr(\n        bytes calldata dnsEncodedName,\n        bytes calldata resolverCalldata\n    ) private view returns (address result) {\n        // Check if the caller is asking for a record on the parent name itself (non-wildcard query)\n        (bool isParentName, bytes32 ensNode) = _isParentName(dnsEncodedName);\n\n        if (isParentName) {\n            // Try to resolve the parent name using the two `addr()` resolver variants\n            result = addr(ensNode);\n            if (result == address(0)) {\n                bytes memory addrBytes = addr(ensNode, COIN_TYPE_ETH);\n                if (addrBytes.length != 0) {\n                    result = addrBytes.toAddress();\n                }\n            }\n        } else {\n            // Caller has issued a wildcard query. Defer to the concrete implementation of this contract\n            (bytes calldata childUtf8Encoded, bytes calldata parentDnsEncoded) = dnsEncodedName.splitParentChildNames();\n            ensNode = parentEnsNodes[parentDnsEncoded];\n            result = _resolveWildcardEthAddr(childUtf8Encoded, parentDnsEncoded);\n        }\n\n        // No luck. If our fallback resolver also happens to implement the `resolve()` wildcard standard then we can try\n        // that as a final option\n        address passthrough = getPassthroughTarget(ensNode);\n        if (result == address(0) && passthrough.supportsInterface(type(IExtendedResolver).interfaceId)) {\n            bytes memory encodedResult = IExtendedResolver(passthrough).resolve(dnsEncodedName, resolverCalldata);\n            (result) = abi.decode(encodedResult, (address));\n        }\n    }\n\n    function _resolveTextRecord(\n        bytes calldata dnsEncodedName,\n        string calldata key,\n        bytes calldata resolverCalldata\n    ) private view returns (string memory result) {\n        // Check if the caller is asking for a record on the parent name itself (non-wildcard query)\n        (bool isParentName, bytes32 ensNode) = _isParentName(dnsEncodedName);\n        if (isParentName) {\n            result = text(ensNode, key);\n        } else {\n            // Caller has issued a wildcard query. Defer to the concrete implementation of this contract\n            (bytes calldata childUtf8Encoded, bytes calldata parentDnsEncoded) = dnsEncodedName.splitParentChildNames();\n            ensNode = parentEnsNodes[parentDnsEncoded];\n            result = _resolveWildcardTextRecord(childUtf8Encoded, parentDnsEncoded, key);\n        }\n\n        // No luck. If our fallback resolver also happens to implement the `resolve()` wildcard standard then we can try\n        // that as a final option\n        address passthrough = getPassthroughTarget(ensNode);\n        if (bytes(result).length == 0 && passthrough.supportsInterface(type(IExtendedResolver).interfaceId)) {\n            bytes memory encodedResult = IExtendedResolver(passthrough).resolve(dnsEncodedName, resolverCalldata);\n            (result) = abi.decode(encodedResult, (string));\n        }\n    }\n\n    function _parseKeyFromCalldata(bytes calldata resolverCalldata) private pure returns (string calldata key) {\n        // ENS resolvers expect that the `key` for text queries is passed in via calldata.\n        //\n        // Until this is implemented in Solidity, we have to hand-pick the string out\n        // of the calldata ourself: https://github.com/ethereum/solidity/issues/13518\n        //\n        // Here's the cleaner version once the above is implemented:\n        //    (, string calldata key) = abi.decode(resolverCalldata[4:], (bytes32, string calldata));\n        //\n        // Reminder: the text resolver signature is `text(bytes32 ensNode, string [calldata] key)`\n        //\n        // Offset math:\n        //    - 4 bytes for the function selector for `text(bytes32,string)`\n        //    - 32 bytes for the `ensNode` as bytes32\n        //    - 32 bytes to encode the offset to start of data part of the dynamic string parameter\n        //         (see https://docs.soliditylang.org/en/v0.8.20/abi-spec.html#use-of-dynamic-types)\n        //    - 32 bytes for the string's length: uint256(len(bytes(key_as_utf8_string)))\n        //    - Remainder is the UTF8 encoding of the key, right-padded to a multiple of 32 bytes\n        uint256 keyLengthOffset = 4 + 32 + 32;\n        uint256 keyOffset = keyLengthOffset + 32;\n\n        uint256 keyLength = abi.decode(resolverCalldata[keyLengthOffset:], (uint256));\n\n        key = string(resolverCalldata[keyOffset:keyOffset + keyLength]);\n    }\n\n    function _isParentName(bytes calldata dnsEncodedName) internal view returns (bool, bytes32 ensNode) {\n        ensNode = parentEnsNodes[dnsEncodedName];\n        return (ensNode != bytes32(0), ensNode);\n    }\n\n    function _nodeOwner(bytes32 node) internal view returns (address) {\n        address owner = ensRegistry.owner(node);\n        if (owner == address(ensNameWrapper)) {\n            owner = ensNameWrapper.ownerOf(uint256(node));\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/feePolicies/FeePolicyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { IFeePolicy } from \"./IFeePolicy.sol\";\n\nabstract contract FeePolicyBase is ERC165, IFeePolicy {\n    function supportsInterface(bytes4 interfaceID) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceID == type(IFeePolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/feePolicies/FlatFeePolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport { FeePolicyBase } from \"./FeePolicyBase.sol\";\nimport { IENSGuilds } from \"../ensGuilds/interfaces/IENSGuilds.sol\";\nimport { IFeePolicy } from \"./IFeePolicy.sol\";\n\n/**\n * @title FlatFeePolicy\n * @notice A common implementation of IFeePolicy that can be used to configure\n * flat-rate fees for multiple guilds simultaneously\n */\ncontract FlatFeePolicy is Context, FeePolicyBase, ReverseClaimer {\n    using ERC165Checker for address;\n\n    IENSGuilds public immutable ensGuilds;\n    struct FeeInfo {\n        address feeToken;\n        uint256 fee;\n        address feePaidTo;\n    }\n    mapping(bytes32 => FeeInfo) public guildFees;\n\n    constructor(\n        ENS _ensRegistry,\n        address _ensGuilds,\n        address reverseRecordOwner\n    ) ReverseClaimer(_ensRegistry, reverseRecordOwner) {\n        // solhint-disable-next-line reason-string, custom-errors\n        require(_ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        ensGuilds = IENSGuilds(_ensGuilds);\n    }\n\n    /**\n     * @notice Configures a flat fee for the given guild. The caller must be the guild's admin\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param feeToken The token contract the fee must be paid in (if any). Address(0) designates native Ether.\n     * @param fee The amount (in base unit) that must be paid\n     * @param feePaidTo The address that should receive payment of the fee\n     */\n    function setFlatFee(bytes32 guildHash, address feeToken, uint256 fee, address feePaidTo) external {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string, custom-errors\n        require(ensGuilds.guildAdmin(guildHash) == _msgSender());\n\n        guildFees[guildHash] = FeeInfo({ feeToken: feeToken, fee: fee, feePaidTo: feePaidTo });\n    }\n\n    /**\n     * @inheritdoc IFeePolicy\n     */\n    function tagClaimFee(\n        bytes32 guildHash,\n        string calldata,\n        address,\n        bytes calldata\n    ) external view virtual override returns (address tokenContract, uint256 fee, address feePaidTo) {\n        FeeInfo storage feeInfo = guildFees[guildHash];\n        return (feeInfo.feeToken, feeInfo.fee, feeInfo.feePaidTo);\n    }\n}\n"
    },
    "contracts/feePolicies/IFeePolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title IFeePolicy\n * @notice An interface for Guilds to implement that will specify how fees must be paid for guild tag mints\n */\ninterface IFeePolicy is IERC165 {\n    /**\n     * @notice Returns the fee required to mint the given guild tag by the given minter\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\n     * @param extraClaimArgs Any additional arguments that would be passed by the minter to the claimGuildTag() function\n     * @return tokenContract The token contract the fee must be paid in (if any). Address(0) designates native Ether.\n     * @return fee The amount (in base unit) that must be paid\n     * @return feePaidTo The address that should receive payment of the fee\n     */\n    function tagClaimFee(\n        bytes32 guildHash,\n        string calldata tag,\n        address claimant,\n        bytes calldata extraClaimArgs\n    ) external view returns (address tokenContract, uint256 fee, address feePaidTo);\n}\n"
    },
    "contracts/libraries/ENSByteUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ensdomains/ens-contracts/blob/340a6d05cd00d078ae40edbc58c139eb7048189a/contracts/resolvers/profiles/AddrResolver.sol\n\npragma solidity ^0.8.4;\n\n/*\n * @dev Converts addresses to and from their byte-string representations\n */\nlibrary ENSByteUtils {\n    // solhint-disable\n    function toAddress(bytes memory b) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12)) // cspell:disable-line\n        }\n    }\n\n    function toBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12))) // cspell:disable-line\n        }\n    }\n    // solhint-enable\n}\n"
    },
    "contracts/libraries/ENSNamehash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Source: https://github.com/JonahGroendal/ens-namehash/blob/master/contracts/ENSNamehash.sol\n\npragma solidity ^0.8.4;\n\n/*\n * @dev Solidity implementation of the ENS namehash algorithm.\n *\n * Warning! Does not normalize or validate names before hashing.\n */\nlibrary ENSNamehash {\n    function namehash(bytes memory domain) internal pure returns (bytes32) {\n        return namehash(domain, 0);\n    }\n\n    function namehash(bytes memory domain, uint i) internal pure returns (bytes32) {\n        if (domain.length <= i) return 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n        uint len = LabelLength(domain, i);\n\n        return keccak256(abi.encodePacked(namehash(domain, i + len + 1), keccak(domain, i, len)));\n    }\n\n    function LabelLength(bytes memory domain, uint i) private pure returns (uint) {\n        uint len;\n        while (i + len != domain.length && domain[i + len] != 0x2e) {\n            len++;\n        }\n        return len;\n    }\n\n    function keccak(bytes memory data, uint offset, uint len) private pure returns (bytes32 ret) {\n        require(offset + len <= data.length);\n        assembly {\n            ret := keccak256(add(add(data, 32), offset), len)\n        }\n    }\n}\n"
    },
    "contracts/libraries/ENSParentName.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary ENSParentName {\n    /**\n     * @dev Finds the parent name of a given ENS name, or the empty string if there is no parent.\n     *      Assumes the given name is already a well-formed ENS name, and does not check for invalid input.\n     * @param name A DNS-encoded name, e.g. 0x03666f6f03626172047465737400 for the name `foo.bar.test`\n     * @return child The UTF8-encoded child label, e.g. 0x666f6f for `foo`\n     * @return parent The DNS-encoded parent, e.g. 03626172047465737400 for `bar.test`\n     */\n    function splitParentChildNames(\n        bytes calldata name\n    ) internal pure returns (bytes calldata child, bytes calldata parent) {\n        uint8 labelLength = uint8(name[0]);\n        return (name[1:labelLength + 1], name[labelLength + 1:]);\n    }\n}\n"
    },
    "contracts/libraries/StringParsing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary StringParsing {\n    /**\n     * @dev Parses a UTF8 string of digits representing an unsigned integer.\n     */\n    function parseUint256(bytes calldata b) internal pure returns (bool valid, uint256 parsed) {\n        uint256 i;\n        parsed = 0;\n        for (i = 0; i < b.length; i++) {\n            if (b[i] < bytes1(0x30) || b[i] > bytes1(0x39)) {\n                return (false, 0);\n            }\n            uint256 c = uint(uint8(b[i])) - 48;\n            parsed = parsed * 10 + c;\n        }\n        return (true, parsed);\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/AllowlistTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\n\nimport { BaseTagsAuthPolicy } from \"./BaseTagsAuthPolicy.sol\";\nimport { IENSGuilds } from \"../ensGuilds/interfaces/IENSGuilds.sol\";\nimport { ITagsAuthPolicy } from \"./ITagsAuthPolicy.sol\";\n\n/**\n * @title AllowlistTagsAuthPolicy\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting\n * guild tags to only allowlisted addresses.\n * A separate allowlist is maintained per each guild, and may only be updated by that guild's registered admin.\n */\ncontract AllowlistTagsAuthPolicy is BaseTagsAuthPolicy, ReverseClaimer {\n    mapping(bytes32 => mapping(address => bool)) public guildAllowlists;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(\n        ENS _ensRegistry,\n        IENSGuilds ensGuilds,\n        address reverseRecordOwner\n    ) BaseTagsAuthPolicy(ensGuilds) ReverseClaimer(_ensRegistry, reverseRecordOwner) {}\n\n    function allowMint(bytes32 guildHash, address minter) external onlyGuildAdmin(guildHash) {\n        guildAllowlists[guildHash][minter] = true;\n    }\n\n    function disallowMint(bytes32 guildHash, address minter) external onlyGuildAdmin(guildHash) {\n        guildAllowlists[guildHash][minter] = false;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canClaimTag(\n        bytes32 guildHash,\n        string calldata,\n        address claimant,\n        address,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        return guildAllowlists[guildHash][claimant];\n    }\n\n    /**\n     * @dev removes the claimant from the guild's allowlist\n     */\n    function _onTagClaimed(\n        bytes32 guildHash,\n        string calldata,\n        address claimant,\n        address,\n        bytes calldata\n    ) internal virtual override returns (string memory tagToRevoke) {\n        guildAllowlists[guildHash][claimant] = false;\n        return \"\";\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canRevokeTag(\n        address,\n        bytes32,\n        string calldata,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canTransferTag(\n        bytes32,\n        string calldata,\n        address transferredBy,\n        address currentOwner,\n        address,\n        bytes calldata\n    ) external pure returns (bool) {\n        return transferredBy == currentOwner;\n    }\n\n    function _onTagRevoked(address, address, bytes32, string memory) internal virtual override {\n        return;\n    }\n\n    function _onTagTransferred(bytes32, string calldata, address, address, address) internal virtual override {\n        return;\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/BaseTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { ITagsAuthPolicy } from \"./ITagsAuthPolicy.sol\";\nimport { IENSGuilds } from \"../ensGuilds/interfaces/IENSGuilds.sol\";\n\n/**\n * @title BaseTagsAuthPolicy\n * @notice An base implementation of ITagsAuthPolicy\n */\nabstract contract BaseTagsAuthPolicy is ITagsAuthPolicy, ERC165, Context, ReentrancyGuard {\n    using ERC165Checker for address;\n\n    IENSGuilds public immutable ensGuilds;\n\n    constructor(IENSGuilds _ensGuilds) {\n        // solhint-disable-next-line reason-string, custom-errors\n        require(_ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        ensGuilds = _ensGuilds;\n    }\n\n    modifier onlyEnsGuildsContract() {\n        // solhint-disable-next-line reason-string, custom-errors\n        require(_msgSender() == address(ensGuilds));\n        _;\n    }\n\n    modifier onlyGuildAdmin(bytes32 guildEnsNode) {\n        // solhint-disable-next-line reason-string, custom-errors\n        require(ensGuilds.guildAdmin(guildEnsNode) == _msgSender());\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\n     * is deferred to the implementation.\n     */\n    function onTagClaimed(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external override nonReentrant onlyEnsGuildsContract returns (string memory tagToRevoke) {\n        return _onTagClaimed(guildEnsNode, tag, claimant, recipient, extraClaimArgs);\n    }\n\n    /**\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\n     */\n    function _onTagClaimed(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) internal virtual returns (string memory tagToRevoke);\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\n     * is deferred to the implementation.\n     */\n    function onTagRevoked(\n        address revokedBy,\n        address revokedFrom,\n        bytes32 guildEnsNode,\n        string memory tag\n    ) external override nonReentrant onlyEnsGuildsContract {\n        _onTagRevoked(revokedBy, revokedFrom, guildEnsNode, tag);\n    }\n\n    /**\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\n     */\n    function _onTagRevoked(\n        address revokedBy,\n        address revokedFrom,\n        bytes32 guildEnsNode,\n        string memory tag\n    ) internal virtual;\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\n     * is deferred to the implementation.\n     */\n    function onTagTransferred(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address transferredBy,\n        address prevOwner,\n        address newOwner\n    ) external override nonReentrant onlyEnsGuildsContract {\n        _onTagTransferred(guildEnsNode, tag, transferredBy, prevOwner, newOwner);\n    }\n\n    /**\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\n     */\n    function _onTagTransferred(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address transferredBy,\n        address prevOwner,\n        address newOwner\n    ) internal virtual;\n}\n"
    },
    "contracts/tagsAuthPolicies/ITagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title TagsAuthPolicy\n * @notice An interface for Guilds to implement that will control authorization for minting tags within that guild\n */\ninterface ITagsAuthPolicy is IERC165 {\n    /**\n     * @notice Checks whether a certain address (claimant) may claim a given guild tag that has been revoked or\n     * has never been claimed\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\n     * @param recipient The address that would receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     */\n    function canClaimTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external view returns (bool);\n\n    /**\n     * @dev Called by ENSGuilds once a tag has been claimed.\n     * Provided for auth policies to update local state, such as erasing an address from an allowlist after that\n     * address has successfully minted a tag.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\n     * @param claimant The address that claimed the tag (not necessarily the address that received it)\n     * @param recipient The address that received receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     * @return tagToRevoke Any tag that should be revoked as a consequence of the given tag\n     * being claimed. Returns empty string if no tag should be revoked.\n     */\n    function onTagClaimed(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external returns (string memory tagToRevoke);\n\n    /**\n     * @notice Checks whether a given guild tag is eligible to be revoked\n     * @param revokedBy The address that would attempt to revoke it\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\n     * @param extraRevokeArgs Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function canRevokeTag(\n        address revokedBy,\n        bytes32 guildEnsNode,\n        string calldata tag,\n        bytes calldata extraRevokeArgs\n    ) external view returns (bool);\n\n    /**\n     * @notice Called by ENSGuilds once a tag has been revoked.\n     * @param revokedBy The address that revoked it\n     * @param revokedFrom The address who owned it when it was revoked\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\n     */\n    function onTagRevoked(address revokedBy, address revokedFrom, bytes32 guildEnsNode, string memory tag) external;\n\n    /**\n     * @notice Checks whether a tag can be transferred. Implementations may trust that `currentOwner` is the\n     * owner of the given tag.\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\n     * @param transferredBy The address initiating the transfer. May be different than the currentOwner, such\n     * as an admin or a marketplace contract\n     * @param currentOwner The address currently owning the given tag\n     * @param newOwner The address that would receive the tag\n     * @param extraTransferArgs Any additional arguments necessary for assessing whether a tag may be transferred\n     */\n    function canTransferTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address transferredBy,\n        address currentOwner,\n        address newOwner,\n        bytes calldata extraTransferArgs\n    ) external view returns (bool);\n\n    /**\n     * @notice Called by ENSGuilds once a tag has been transferred\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tag The tag that was transferred\n     * @param transferredBy The address initiating the transfer\n     * @param prevOwner The address that previously owned the tag\n     * @param newOwner The address that received the tag\n     */\n    function onTagTransferred(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address transferredBy,\n        address prevOwner,\n        address newOwner\n    ) external;\n}\n"
    },
    "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC1155 } from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport { StringParsing } from \"../libraries/StringParsing.sol\";\nimport { BaseTagsAuthPolicy } from \"./BaseTagsAuthPolicy.sol\";\nimport { IENSGuilds } from \"../ensGuilds/interfaces/IENSGuilds.sol\";\nimport { ITagsAuthPolicy } from \"./ITagsAuthPolicy.sol\";\n\n/**\n * @title NFTTagsAuthPolicy\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses\n * that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once\n * per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being\n * revoked once the second is minted, regardless of whether ownership of that TokenID has changed.\n *\n * A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\n */\ncontract NFTTagsAuthPolicy is BaseTagsAuthPolicy, ReverseClaimer {\n    using ERC165Checker for address;\n    using StringParsing for bytes;\n    using Strings for string;\n\n    error TokenIDTagMustMatchCallerTokenID();\n\n    enum TokenStandard {\n        ERC721,\n        ERC1155\n    }\n    struct TagClaim {\n        string tag;\n        address claimedBy;\n    }\n    struct GuildInfo {\n        address tokenContract;\n        TokenStandard tokenStandard;\n        mapping(uint256 => TagClaim) tagClaims;\n    }\n    mapping(bytes32 => GuildInfo) public guilds;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(\n        ENS _ensRegistry,\n        IENSGuilds ensGuilds,\n        address reverseRecordOwner\n    ) BaseTagsAuthPolicy(ensGuilds) ReverseClaimer(_ensRegistry, reverseRecordOwner) {}\n\n    /**\n     * @notice Registers the specific NFT collection that a user must be a member of to mint a guild tag\n     * @param guildEnsNode The ENS namehash of the guild's domain\n     * @param tokenContract The ERC721 or ERC1155 collection to use\n     */\n    function setTokenContract(bytes32 guildEnsNode, address tokenContract) external onlyGuildAdmin(guildEnsNode) {\n        // token contract must be ERC721 or ERC1155\n        if (tokenContract.supportsInterface(type(IERC721).interfaceId)) {\n            guilds[guildEnsNode].tokenStandard = TokenStandard.ERC721;\n        } else if (tokenContract.supportsInterface(type(IERC1155).interfaceId)) {\n            guilds[guildEnsNode].tokenStandard = TokenStandard.ERC1155;\n        } else {\n            // solhint-disable-next-line reason-string, custom-errors\n            revert();\n        }\n\n        guilds[guildEnsNode].tokenContract = tokenContract;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`.\n     * The caller must own the given TokenID.\n     */\n    function canClaimTag(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) external view virtual override returns (bool) {\n        GuildInfo storage guildInfo = guilds[guildEnsNode];\n        address tokenContract = guildInfo.tokenContract;\n\n        // parse NFT token ID from the tag claim args\n        if (extraClaimArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        // check that claimant owns this NFT\n        bool ownsNFT = false;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            ownsNFT = IERC721(tokenContract).ownerOf(nftTokenId) == claimant;\n        } else {\n            ownsNFT = IERC1155(tokenContract).balanceOf(claimant, nftTokenId) > 0;\n        }\n        if (!ownsNFT) {\n            return false;\n        }\n\n        // if the tag looks like a token ID, it should be the same as the token ID\n        // used to authorize the mint\n        (bool isUint, uint256 parsedTokenID) = bytes(tag).parseUint256();\n        if (isUint && parsedTokenID != nftTokenId) {\n            revert TokenIDTagMustMatchCallerTokenID();\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev records the latest tag minted from the given TokenID (via extraClaimArgs), and returns whichever\n     * tag was last minted from the same TokenID.\n     */\n    function _onTagClaimed(\n        bytes32 guildEnsNode,\n        string calldata tag,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) internal virtual override returns (string memory tagToRevoke) {\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        tagToRevoke = guilds[guildEnsNode].tagClaims[nftTokenId].tag;\n\n        guilds[guildEnsNode].tagClaims[nftTokenId].tag = tag;\n        guilds[guildEnsNode].tagClaims[nftTokenId].claimedBy = claimant;\n\n        return tagToRevoke;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canRevokeTag(\n        address,\n        bytes32 guildEnsNode,\n        string calldata tag,\n        bytes calldata extraRevokeArgs\n    ) external view virtual override returns (bool) {\n        if (extraRevokeArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraRevokeArgs));\n\n        GuildInfo storage guildInfo = guilds[guildEnsNode];\n        address tokenContract = guildInfo.tokenContract;\n\n        // check that the given tag was indeed claimed from the given NFT\n        if (!guildInfo.tagClaims[nftTokenId].tag.equal(tag)) {\n            return false;\n        }\n\n        // check that the current owner of the given NFT is the same as the owner when the tag was claimed\n        address previousClaimant = guildInfo.tagClaims[nftTokenId].claimedBy;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            address currentTokenOwner = IERC721(tokenContract).ownerOf(nftTokenId);\n            return currentTokenOwner != previousClaimant;\n        } else {\n            return IERC1155(tokenContract).balanceOf(previousClaimant, nftTokenId) == 0;\n        }\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canTransferTag(\n        bytes32,\n        string calldata,\n        address transferredBy,\n        address currentOwner,\n        address,\n        bytes calldata\n    ) external pure returns (bool) {\n        return transferredBy == currentOwner;\n    }\n\n    function _onTagRevoked(address, address, bytes32, string memory) internal virtual override {\n        return;\n    }\n\n    function _onTagTransferred(bytes32, string calldata, address, address, address) internal virtual override {\n        return;\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/OpenTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ReverseClaimer } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/ReverseClaimer.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { ITagsAuthPolicy } from \"./ITagsAuthPolicy.sol\";\n\ncontract OpenTagsAuthPolicy is ITagsAuthPolicy, ERC165, ReverseClaimer {\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(ENS _ensRegistry, address reverseRecordOwner) ReverseClaimer(_ensRegistry, reverseRecordOwner) {}\n\n    function canClaimTag(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external pure virtual override returns (bool) {\n        return true;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (string memory tagToRevoke) {\n        return \"\";\n    }\n\n    function canRevokeTag(\n        address,\n        bytes32,\n        string calldata,\n        bytes calldata\n    ) external pure virtual override returns (bool) {\n        return false;\n    }\n\n    function canTransferTag(\n        bytes32,\n        string calldata,\n        address transferredBy,\n        address currentOwner,\n        address,\n        bytes calldata\n    ) external pure returns (bool) {\n        return transferredBy == currentOwner;\n    }\n\n    function onTagRevoked(address, address, bytes32, string memory) external pure virtual override {\n        return;\n    }\n\n    function onTagTransferred(bytes32, string calldata, address, address, address) external pure override {\n        return;\n    }\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/ClaimGuildTagReentrancyAttacker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { IENSGuilds } from \"../../ensGuilds/interfaces/IENSGuilds.sol\";\n\n/**\n * ClaimGuildTagReentrancyAttacker is a contract that exposes an apparently\n * benign lookup function that will re-invoke `claimGuildTag`.\n */\ncontract ClaimGuildTagReentrancyAttacker {\n    IENSGuilds private immutable ensGuilds;\n\n    bytes32 private guildEnsNode;\n    string private tag;\n    address private recipient;\n    bytes private extraClaimArgs;\n\n    constructor(\n        IENSGuilds _ensGuilds,\n        bytes32 _guildEnsNode,\n        string memory _tag,\n        address _recipient,\n        bytes memory _extraClaimArgs\n    ) {\n        ensGuilds = _ensGuilds;\n\n        guildEnsNode = _guildEnsNode;\n        tag = _tag;\n        recipient = _recipient;\n        extraClaimArgs = _extraClaimArgs;\n    }\n\n    function insidiousLookupFunction() external returns (bool) {\n        ensGuilds.claimGuildTag(guildEnsNode, tag, recipient, extraClaimArgs);\n        return true;\n    }\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/IClaimGuildTagReentrancyAttacker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IClaimGuildTagReentrancyAttacker {\n    function insidiousLookupFunction() external view returns (bool);\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/ReentrancyAttackAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport { ITagsAuthPolicy } from \"../../tagsAuthPolicies/ITagsAuthPolicy.sol\";\nimport { IClaimGuildTagReentrancyAttacker } from \"./IClaimGuildTagReentrancyAttacker.sol\";\n\n/**\n * ReentrancyAttackAuthPolicy is a dummy TagsAuthPolicy that includes logic in\n * its `canClaimTag` implementation that calls out to a function on a\n * separate contract.\n *\n * That separate contract exposes an apparently benign lookup function that\n * will re-invoke `claimGuildTag`.\n */\ncontract ReentrancyAttackAuthPolicy is ITagsAuthPolicy, ERC165 {\n    IClaimGuildTagReentrancyAttacker private immutable attacker;\n\n    constructor(IClaimGuildTagReentrancyAttacker _attacker) {\n        attacker = _attacker;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function canClaimTag(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        bool canMint = attacker.insidiousLookupFunction();\n        return canMint;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (string memory tagToRevoke) {\n        return \"\";\n    }\n\n    function canTransferTag(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        address,\n        bytes calldata\n    ) external pure override returns (bool) {\n        return false;\n    }\n\n    function onTagTransferred(bytes32, string calldata, address, address, address) external pure override {\n        return;\n    }\n\n    function canRevokeTag(\n        address,\n        bytes32,\n        string calldata,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        return false;\n    }\n\n    function onTagRevoked(address, address, bytes32, string memory) external virtual override {\n        return;\n    }\n}\n"
    },
    "contracts/testHelpers/ENSParentNameTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ENSParentName } from \"../libraries/ENSParentName.sol\";\n\ncontract ENSParentNameTestHelper {\n    using ENSParentName for bytes;\n\n    function splitParentChildNames(\n        bytes calldata name\n    ) external pure returns (bytes calldata child, bytes calldata parent) {\n        return name.splitParentChildNames();\n    }\n}\n"
    },
    "contracts/testHelpers/ensResolverMocks/MockAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {\n    AddrResolver,\n    IAddressResolver\n} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract MockAddressResolver is AddrResolver {\n    function addr(bytes32 node) public view override returns (address payable) {\n        return super.addr(node);\n    }\n\n    function isAuthorised(bytes32) internal pure override returns (bool) {\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view override(AddrResolver) returns (bool) {\n        return interfaceID == type(IAddressResolver).interfaceId || ERC165.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/testHelpers/ensResolverMocks/MockAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { AddrResolver, IAddrResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\";\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract MockAddrResolver is AddrResolver {\n    function isAuthorised(bytes32) internal pure override returns (bool) {\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(AddrResolver) returns (bool) {\n        return interfaceID == type(IAddrResolver).interfaceId || ERC165.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/testHelpers/ensResolverMocks/MockTextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { TextResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol\";\n\ncontract MockTextResolver is TextResolver {\n    function isAuthorised(bytes32) internal pure override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/testHelpers/ensResolverMocks/MockWildcardResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { ExtendedResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ExtendedResolver.sol\";\nimport { IExtendedResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\n\ncontract MockWildcardResolver is ExtendedResolver, ERC165 {\n    mapping(bytes32 => address) private addresses;\n    mapping(bytes32 => mapping(string => string)) private texts;\n\n    function supportsInterface(bytes4 interfaceID) public view override returns (bool) {\n        return interfaceID == type(IExtendedResolver).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function addr(bytes32 node) public view returns (address payable) {\n        return payable(addresses[node]);\n    }\n\n    function setAddr(bytes32 node, address a) external {\n        addresses[node] = a;\n    }\n\n    function setText(bytes32 node, string calldata key, string calldata value) external {\n        texts[node][key] = value;\n    }\n\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\n        return texts[node][key];\n    }\n}\n"
    },
    "contracts/testHelpers/IENSLegacyPublicResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// Source: https://etherscan.io/address/0x226159d592e2b063810a10ebf6dcbada94ed68b8#code\n\nimport { IABIResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol\";\nimport { IAddrResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport { IContentHashResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\";\nimport { IInterfaceResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol\";\nimport { INameResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\";\nimport { IPubkeyResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol\";\nimport { ITextResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\";\n\ninterface IENSLegacyPublicResolver is\n    IABIResolver,\n    IAddrResolver,\n    IContentHashResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver\n{\n    /**\n     * @dev Sets or clears an authorisation.\n     * Authorisations are specific to the caller. Any account can set an authorisation\n     * for any name, but the authorisation that is checked will be that of the\n     * current owner of a name. Thus, transferring a name effectively clears any\n     * existing authorisations, and new authorisations can be set in advance of\n     * an ownership transfer if desired.\n     *\n     * @param node The name to change the authorisation on.\n     * @param target The address that is to be authorised or deauthorised.\n     * @param isAuthorised True if the address should be authorised, or false if it should be deauthorised.\n     */\n    function setAuthorisation(bytes32 node, address target, bool isAuthorised) external;\n\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n\n    function setAddr(bytes32 node, address a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n\n    function setName(bytes32 node, string calldata newName) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n}\n"
    },
    "contracts/testHelpers/NonPayableContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// A contract that reverts any TX that tries to send it ETH\ncontract NonPayableContract {\n    // solhint-disable-next-line payable-fallback\n    fallback() external {\n        // solhint-disable-next-line custom-errors\n        revert(\"This contract is not payable!\");\n    }\n}\n"
    },
    "contracts/testHelpers/StubWildcardResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { NameEncoder } from \"@ensdomains/ens-contracts/contracts/utils/NameEncoder.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { INameWrapper } from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\n\nimport { WildcardResolverBase } from \"../ensWildcardResolvers/WildcardResolverBase.sol\";\n\ncontract StubWildcardResolverBase is WildcardResolverBase {\n    using NameEncoder for string;\n\n    address private _resolveWildcardEthAddrRetVal;\n    string private _resolveWildcardTextRecordRetVal;\n\n    constructor(ENS _ensRegistry, INameWrapper _ensNameWrapper) WildcardResolverBase(_ensRegistry, _ensNameWrapper) {\n        return;\n    }\n\n    function setPassthroughTarget(string calldata parentEnsName, address target) external {\n        (bytes memory encodedName, bytes32 ensNode) = parentEnsName.dnsEncodeName();\n        _setPassthroughTarget(ensNode, target);\n        parentEnsNodes[encodedName] = ensNode;\n    }\n\n    function _resolveWildcardEthAddr(bytes calldata, bytes calldata) internal view override returns (address) {\n        return _resolveWildcardEthAddrRetVal;\n    }\n\n    function _resolveWildcardTextRecord(\n        bytes calldata,\n        bytes calldata,\n        string calldata\n    ) internal view override returns (string memory) {\n        return _resolveWildcardTextRecordRetVal;\n    }\n\n    function isAuthorised(bytes32) internal pure override returns (bool) {\n        return true;\n    }\n\n    // solhint-disable func-name-mixedcase\n    function stub_resolveWildcardEthAddr(address retVal) external {\n        _resolveWildcardEthAddrRetVal = retVal;\n    }\n\n    function stub_resolveWildcardTextRecord(string calldata retVal) external {\n        _resolveWildcardTextRecordRetVal = retVal;\n    }\n    // solhint-enable func-name-mixedcase\n}\n"
    },
    "contracts/testHelpers/TagTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC165, IERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { ITagsAuthPolicy } from \"../tagsAuthPolicies/ITagsAuthPolicy.sol\";\n\ncontract TagTestHelper is ITagsAuthPolicy, ERC165 {\n    string private _onTagClaimedRetVal;\n    bool private _tagCanBeRevokedRetVal = true;\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function canClaimTag(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        return true;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (string memory tagToRevoke) {\n        return _onTagClaimedRetVal;\n    }\n\n    function canTransferTag(\n        bytes32,\n        string calldata,\n        address,\n        address,\n        address,\n        bytes calldata\n    ) external pure override returns (bool) {\n        return false;\n    }\n\n    function onTagTransferred(bytes32, string calldata, address, address, address) external pure override {\n        return;\n    }\n\n    function canRevokeTag(\n        address,\n        bytes32,\n        string calldata,\n        bytes calldata\n    ) external view virtual override returns (bool) {\n        return _tagCanBeRevokedRetVal;\n    }\n\n    function onTagRevoked(address, address, bytes32, string memory) external virtual override {\n        return;\n    }\n\n    // solhint-disable func-name-mixedcase\n    function stub_tagCanBeRevokedReturnVal(bool retVal) external {\n        _tagCanBeRevokedRetVal = retVal;\n    }\n\n    function stub_onTagClaimedReturnVal(string calldata retVal) external {\n        _onTagClaimedRetVal = retVal;\n    }\n    // solhint-enable func-name-mixedcase\n}\n"
    },
    "contracts/testHelpers/TestERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport { ERC721URIStorage, ERC721 } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\ncontract TestERC721 is ERC721URIStorage {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n    function mint(address to, uint256 tokenId) external {\n        _mint(to, tokenId);\n    }\n\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) external {\n        _setTokenURI(tokenId, _tokenURI);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}