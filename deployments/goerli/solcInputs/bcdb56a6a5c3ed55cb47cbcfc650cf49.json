{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(bytes32 node, uint256 coinType)\n        external\n        view\n        returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ensGuilds/ENSGuilds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\n\nimport \"./interfaces/IENSGuilds.sol\";\nimport \"../feePolicies/FeePolicy.sol\";\nimport \"../tagsAuthPolicies/ITagsAuthPolicy.sol\";\nimport \"./mixins/ENSResolver.sol\";\nimport \"./mixins/ENSGuildsToken.sol\";\nimport \"./mixins/ENSGuildsHumanized.sol\";\n\ncontract ENSGuilds is IENSGuilds, ENSGuildsHumanized, ENSGuildsToken, ENSResolver, ReentrancyGuard {\n    struct GuildInfo {\n        address admin;\n        FeePolicy feePolicy;\n        ITagsAuthPolicy tagsAuthPolicy;\n        bool active;\n        bool deregistered;\n    }\n\n    using ERC165Checker for address;\n\n    /** State */\n    ENS public ensRegistry;\n    mapping(bytes32 => GuildInfo) public guilds;\n\n    /** Errors */\n    error AlreadyRegistered();\n    error ENSGuildsIsNotRegisteredOperator();\n    error NotDomainOwner();\n    error InvalidPolicy(address);\n    error GuildNotActive();\n    error ClaimUnauthorized();\n    error RevokeUnauthorized();\n    error GuildAdminOnly();\n    error TagAlreadyClaimed();\n    error FeeError();\n\n    modifier onlyGuildAdmin(bytes32 guildHash) {\n        if (guilds[guildHash].admin != _msgSender()) {\n            revert GuildAdminOnly();\n        }\n        _;\n    }\n\n    constructor(string memory defaultTokenMetadataUri, ENS _ensRegistry) ERC1155(defaultTokenMetadataUri) {\n        ensRegistry = _ensRegistry;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ENSResolver, ENSGuildsToken, IERC165) returns (bool) {\n        return\n            interfaceId == type(IENSGuilds).interfaceId ||\n            ENSResolver.supportsInterface(interfaceId) ||\n            ENSGuildsToken.supportsInterface(interfaceId) ||\n            ERC165.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function registerGuild(\n        bytes32 ensNode,\n        address admin,\n        address feePolicy,\n        address tagsAuthPolicy\n    ) public override(ENSGuildsHumanized, IENSGuilds) {\n        // Check caller is owner of domain\n        if (ensRegistry.owner(ensNode) != _msgSender()) {\n            revert NotDomainOwner();\n        }\n\n        // Check guild not yet registered\n        if (address(guilds[ensNode].feePolicy) != address(0)) {\n            revert AlreadyRegistered();\n        }\n\n        // Check ENSGuilds contract has been configured as ENS resolver for the guild\n        if (!ensRegistry.isApprovedForAll(_msgSender(), address(this))) {\n            revert ENSGuildsIsNotRegisteredOperator();\n        }\n\n        // Check for valid fee/tagsAuth policies\n        if (!feePolicy.supportsInterface(type(FeePolicy).interfaceId)) {\n            revert InvalidPolicy(feePolicy);\n        }\n        if (!tagsAuthPolicy.supportsInterface(type(ITagsAuthPolicy).interfaceId)) {\n            revert InvalidPolicy(tagsAuthPolicy);\n        }\n\n        guilds[ensNode] = GuildInfo({\n            admin: admin,\n            feePolicy: FeePolicy(feePolicy),\n            tagsAuthPolicy: ITagsAuthPolicy(tagsAuthPolicy),\n            active: true,\n            deregistered: false\n        });\n\n        emit Registered(ensNode);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function deregisterGuild(bytes32 ensNode) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(ensNode) {\n        delete guilds[ensNode];\n        guilds[ensNode].deregistered = true;\n        emit Deregistered(ensNode);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function claimGuildTag(\n        bytes32 guildEnsNode,\n        bytes32 tagHash,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) public payable override(ENSGuildsHumanized, IENSGuilds) nonReentrant {\n        // assert guild is not frozen\n        if (!guilds[guildEnsNode].active) {\n            revert GuildNotActive();\n        }\n\n        // check tag not already registered\n        bytes32 ensNode = keccak256(abi.encodePacked(guildEnsNode, tagHash));\n        if (ensRegistry.owner(ensNode) != address(0)) {\n            revert TagAlreadyClaimed();\n        }\n\n        // check caller is authorized to claim tag\n        ITagsAuthPolicy auth = guilds[guildEnsNode].tagsAuthPolicy;\n        if (!auth.canClaimTag(guildEnsNode, tagHash, _msgSender(), recipient, extraClaimArgs)) {\n            revert ClaimUnauthorized();\n        }\n\n        // fees\n        (address feeToken, uint256 fee, address feePaidTo) = guilds[guildEnsNode].feePolicy.tagClaimFee(\n            guildEnsNode,\n            tagHash,\n            _msgSender(),\n            extraClaimArgs\n        );\n        if (fee != 0) {\n            if (feeToken == address(0)) {\n                if (msg.value != fee) {\n                    revert FeeError();\n                }\n                // solhint-disable-next-line avoid-low-level-calls\n                (bool sent, ) = feePaidTo.call{ value: msg.value }(\"\");\n                if (!sent) revert FeeError();\n            } else {\n                try IERC20(feeToken).transferFrom(_msgSender(), feePaidTo, fee) returns (bool sent) {\n                    if (!sent) revert FeeError();\n                } catch {\n                    revert FeeError();\n                }\n            }\n        }\n\n        // NFT mint\n        _mintNewGuildToken(guildEnsNode, tagHash, recipient);\n\n        // inform auth contract that tag was claimed, then revoke an existing tag if instructed\n        bytes32 tagToRevoke = auth.onTagClaimed(guildEnsNode, tagHash, _msgSender(), recipient, extraClaimArgs);\n        if (tagToRevoke != bytes32(0)) {\n            _revokeTag(guildEnsNode, tagToRevoke);\n        }\n\n        // Register this new name in ENS\n        ensRegistry.setSubnodeRecord(guildEnsNode, tagHash, address(this), address(this), 0);\n\n        // Set forward record in ENS resolver\n        _setEnsForwardRecord(ensNode, recipient);\n\n        emit TagClaimed(guildEnsNode, tagHash, recipient);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function claimGuildTagsBatch(\n        bytes32 guildEnsNode,\n        bytes32[] calldata tagHashes,\n        address[] calldata recipients,\n        bytes[] calldata extraClaimArgs\n    ) external payable override {\n        for (uint i = 0; i < tagHashes.length; i++) {\n            claimGuildTag(guildEnsNode, tagHashes[i], recipients[i], extraClaimArgs[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function guildAdmin(bytes32 guildHash) public view override(ENSGuildsHumanized, IENSGuilds) returns (address) {\n        return guilds[guildHash].admin;\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function revokeGuildTag(\n        bytes32 guildEnsNode,\n        bytes32 tagHash,\n        bytes calldata extraData\n    ) public override(ENSGuildsHumanized, IENSGuilds) nonReentrant {\n        GuildInfo storage guild = guilds[guildEnsNode];\n\n        // revoke authorized?\n        ITagsAuthPolicy auth = guilds[guildEnsNode].tagsAuthPolicy;\n        if (!guild.deregistered && !auth.tagCanBeRevoked(_msgSender(), guildEnsNode, tagHash, extraData)) {\n            revert RevokeUnauthorized();\n        }\n        _revokeTag(guildEnsNode, tagHash);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function revokeGuildTagsBatch(\n        bytes32 guildHash,\n        bytes32[] calldata tagHashes,\n        bytes[] calldata extraData\n    ) external override {\n        for (uint i = 0; i < tagHashes.length; i++) {\n            revokeGuildTag(guildHash, tagHashes[i], extraData[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function updateGuildFeePolicy(\n        bytes32 guildEnsNode,\n        address feePolicy\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(guildEnsNode) {\n        if (!feePolicy.supportsInterface(type(FeePolicy).interfaceId)) {\n            revert InvalidPolicy(feePolicy);\n        }\n        guilds[guildEnsNode].feePolicy = FeePolicy(feePolicy);\n        emit FeePolicyUpdated(guildEnsNode, feePolicy);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function updateGuildTagsAuthPolicy(\n        bytes32 guildEnsNode,\n        address tagsAuthPolicy\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(guildEnsNode) {\n        if (!tagsAuthPolicy.supportsInterface(type(ITagsAuthPolicy).interfaceId)) {\n            revert InvalidPolicy(tagsAuthPolicy);\n        }\n        guilds[guildEnsNode].tagsAuthPolicy = ITagsAuthPolicy(tagsAuthPolicy);\n        emit TagsAuthPolicyUpdated(guildEnsNode, tagsAuthPolicy);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function transferGuildAdmin(\n        bytes32 guildEnsNode,\n        address newAdmin\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(guildEnsNode) {\n        guilds[guildEnsNode].admin = newAdmin;\n        emit AdminTransferred(guildEnsNode, newAdmin);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function setGuildTokenUriTemplate(\n        bytes32 guildEnsNode,\n        string calldata uriTemplate\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(guildEnsNode) {\n        _setGuildTokenURITemplate(guildEnsNode, uriTemplate);\n        emit TokenUriTemplateSet(guildEnsNode, uriTemplate);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function setGuildActive(\n        bytes32 guildEnsNode,\n        bool active\n    ) public override(ENSGuildsHumanized, IENSGuilds) onlyGuildAdmin(guildEnsNode) {\n        guilds[guildEnsNode].active = active;\n        emit SetActive(guildEnsNode, active);\n    }\n\n    /**\n     * @inheritdoc IENSGuilds\n     */\n    function tagOwner(\n        bytes32 guildEnsNode,\n        bytes32 tagHash\n    ) public view override(ENSGuildsHumanized, IENSGuilds) returns (address) {\n        bytes32 tagEnsNode = keccak256(abi.encodePacked(guildEnsNode, tagHash));\n        // if ENSGuilds is not the owner of the tag's ENS node, then the tag itself is not valid\n        // and therefore has no owner\n        if (ensRegistry.owner(tagEnsNode) != address(this)) {\n            return address(0);\n        }\n        return addr(tagEnsNode);\n    }\n\n    function _revokeTag(bytes32 guildEnsNode, bytes32 tagHash) private {\n        address _tagOwner = tagOwner(guildEnsNode, tagHash);\n\n        // check that tag exists\n        if (_tagOwner == address(0)) {\n            revert RevokeUnauthorized();\n        }\n\n        ensRegistry.setSubnodeRecord(guildEnsNode, tagHash, address(0), address(0), 0);\n        _burnGuildToken(guildEnsNode, tagHash, _tagOwner);\n\n        emit TagRevoked(guildEnsNode, tagHash);\n    }\n}\n"
    },
    "contracts/ensGuilds/interfaces/IENSGuilds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\";\n\ninterface IENSGuilds is IAddrResolver, IAddressResolver, IERC1155MetadataURI {\n    /** Events */\n    event Registered(bytes32 indexed guildHash);\n    event Deregistered(bytes32 indexed guildHash);\n    event TagClaimed(bytes32 indexed guildId, bytes32 indexed tagHash, address recipient);\n    event TagRevoked(bytes32 indexed guildId, bytes32 indexed tagHash);\n    event FeePolicyUpdated(bytes32 indexed guildId, address feePolicy);\n    event TagsAuthPolicyUpdated(bytes32 indexed guildId, address tagsAuthPolicy);\n    event AdminTransferred(bytes32 indexed guildId, address newAdmin);\n    event SetActive(bytes32 indexed guildId, bool active);\n    event TokenUriTemplateSet(bytes32 indexed guildId, string uriTemplate);\n\n    /* Functions */\n\n    /**\n     * @notice Registers a new guild from an existing ENS domain.\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \"operator\" for the caller.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param guildAdmin The address that will administrate this guild\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function registerGuild(bytes32 guildHash, address guildAdmin, address feePolicy, address tagsAuthPolicy) external;\n\n    /**\n     * @notice Deregisters a registered guild.\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\n     * @param guildHash The ENS namehash of the guild's domain\n     */\n    function deregisterGuild(bytes32 guildHash) external;\n\n    /**\n     * @notice Claims a guild tag\n     * @param guildHash The namehash of the guild for which the tag should be claimed (e.g. namehash('my-guild.eth'))\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function claimGuildTag(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Claims multiple tags for a guild at once\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHashes Namehashes of each tag to be claimed\n     * @param recipients Recipients of each tag to be claimed\n     * @param extraClaimArgs Per-tag extra arguments required for guild-specific logic, such as authorization.\n     * Must have same length as array of tagHashes, even if each array element is itself empty bytes\n     */\n    function claimGuildTagsBatch(\n        bytes32 guildHash,\n        bytes32[] calldata tagHashes,\n        address[] calldata recipients,\n        bytes[] calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Returns the current owner of the given guild tag.\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\n     */\n    function tagOwner(bytes32 guildHash, bytes32 tagHash) external view returns (address);\n\n    /**\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTag(bytes32 guildHash, bytes32 tagHash, bytes calldata extraData) external;\n\n    /**\n     * @notice Attempts to revoke multiple guild tags\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHashes ENS namehashes of all tags to revoke\n     * @param extraData Additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTagsBatch(bytes32 guildHash, bytes32[] calldata tagHashes, bytes[] calldata extraData) external;\n\n    /**\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     */\n    function updateGuildFeePolicy(bytes32 guildHash, address feePolicy) external;\n\n    /**\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function updateGuildTagsAuthPolicy(bytes32 guildHash, address tagsAuthPolicy) external;\n\n    /**\n     * @notice Sets the metadata URI template string for fetching metadata for a guild's tag NFTs.\n     * May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param uriTemplate The ERC1155 metadata URL template\n     */\n    function setGuildTokenUriTemplate(bytes32 guildHash, string calldata uriTemplate) external;\n\n    /**\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param active The new status\n     */\n    function setGuildActive(bytes32 guildHash, bool active) external;\n\n    /**\n     * @notice Returns the current admin registered for the given guild.\n     * @param guildHash The ENS namehash of the guild's domain\n     */\n    function guildAdmin(bytes32 guildHash) external view returns (address);\n\n    /**\n     * @notice Transfers the role of guild admin to the given address. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param newAdmin The new admin\n     */\n    function transferGuildAdmin(bytes32 guildHash, address newAdmin) external;\n}\n"
    },
    "contracts/ensGuilds/interfaces/IENSGuildsHumanized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IENSGuildsHumanized {\n    function registerGuild(\n        string memory ensName,\n        address guildAdmin,\n        address feePolicy,\n        address tagsAuthPolicy\n    ) external;\n\n    function deregisterGuild(string memory guildEnsName) external;\n\n    function claimGuildTag(\n        string memory guildEnsName,\n        string memory tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable;\n\n    function tagOwner(string memory guildEnsName, string memory tag) external view returns (address);\n\n    function revokeGuildTag(string memory guildEnsName, string memory tag, bytes calldata extraData) external;\n\n    function updateGuildFeePolicy(string memory guildEnsName, address feePolicy) external;\n\n    function updateGuildTagsAuthPolicy(string memory guildEnsName, address tagsAuthPolicy) external;\n\n    function setGuildTokenUriTemplate(string memory guildEnsName, string calldata uriTemplate) external;\n\n    function setGuildActive(string memory guildEnsName, bool active) external;\n\n    function guildAdmin(string memory guildEnsName) external view returns (address);\n\n    function transferGuildAdmin(string memory guildEnsName, address newAdmin) external;\n}\n"
    },
    "contracts/ensGuilds/mixins/ENSGuildsHumanized.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IENSGuilds.sol\";\nimport \"../interfaces/IENSGuildsHumanized.sol\";\nimport \"../../libraries/ENSNamehash.sol\";\n\nabstract contract ENSGuildsHumanized is IENSGuildsHumanized {\n    using ENSNamehash for bytes;\n\n    // Humanized versions\n\n    /**\n     * @notice Registers a new guild from an existing ENS domain.\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \"operator\" for the caller.\n     * @param ensName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param admin The address that will administrate this guild\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function registerGuild(\n        string memory ensName,\n        address admin,\n        address feePolicy,\n        address tagsAuthPolicy\n    ) external override {\n        bytes32 ensNode = bytes(ensName).namehash();\n        registerGuild(ensNode, admin, feePolicy, tagsAuthPolicy);\n    }\n\n    /**\n     * @notice Deregisters a registered guild.\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     */\n    function deregisterGuild(string memory guildEnsName) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        deregisterGuild(guildEnsNode);\n    }\n\n    /**\n     * @notice Claims a guild tag\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag to claim (e.g. 'foobar')\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function claimGuildTag(\n        string memory guildEnsName,\n        string memory tag,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable override {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        bytes32 tagHash = keccak256(bytes(tag));\n        claimGuildTag(guildEnsNode, tagHash, recipient, extraClaimArgs);\n    }\n\n    /**\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag to revoke (e.g. 'foobar')\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTag(string memory guildEnsName, string memory tag, bytes calldata extraData) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        bytes32 tagHash = keccak256(bytes(tag));\n        revokeGuildTag(guildEnsNode, tagHash, extraData);\n    }\n\n    /**\n     * @notice Returns the current owner of the given guild tag.\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tag The tag (e.g. 'foobar')\n     */\n    function tagOwner(string memory guildEnsName, string memory tag) external view returns (address) {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        bytes32 tagHash = keccak256(bytes(tag));\n        return tagOwner(guildEnsNode, tagHash);\n    }\n\n    /**\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     */\n    function updateGuildFeePolicy(string memory guildEnsName, address feePolicy) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        updateGuildFeePolicy(guildEnsNode, feePolicy);\n    }\n\n    /**\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function updateGuildTagsAuthPolicy(string memory guildEnsName, address tagsAuthPolicy) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        updateGuildTagsAuthPolicy(guildEnsNode, tagsAuthPolicy);\n    }\n\n    /**\n     * @notice Sets the metadata URI template string for fetching metadata for a guild's tag NFTs.\n     * May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param uriTemplate The ERC1155 metadata URL template\n     */\n    function setGuildTokenUriTemplate(string memory guildEnsName, string calldata uriTemplate) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        setGuildTokenUriTemplate(guildEnsNode, uriTemplate);\n    }\n\n    /**\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param active The new status\n     */\n    function setGuildActive(string memory guildEnsName, bool active) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        setGuildActive(guildEnsNode, active);\n    }\n\n    /**\n     * @notice Returns the current admin registered for the given guild.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     */\n    function guildAdmin(string memory guildEnsName) external view returns (address) {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        return guildAdmin(guildEnsNode);\n    }\n\n    /**\n     * @notice Transfers the role of guild admin to the given address. May only be called by the guild's registered admin.\n     * @param guildEnsName The guild's full domain name (e.g. 'my-guild.eth')\n     * @param newAdmin The new admin\n     */\n    function transferGuildAdmin(string memory guildEnsName, address newAdmin) external {\n        bytes32 guildEnsNode = bytes(guildEnsName).namehash();\n        transferGuildAdmin(guildEnsNode, newAdmin);\n    }\n\n    // Original versions\n\n    function registerGuild(bytes32, address, address, address) public virtual;\n\n    function deregisterGuild(bytes32) public virtual;\n\n    function claimGuildTag(bytes32, bytes32, address, bytes calldata) public payable virtual;\n\n    function revokeGuildTag(bytes32, bytes32, bytes calldata) public virtual;\n\n    function tagOwner(bytes32, bytes32) public view virtual returns (address);\n\n    function updateGuildFeePolicy(bytes32, address) public virtual;\n\n    function updateGuildTagsAuthPolicy(bytes32, address) public virtual;\n\n    function setGuildTokenUriTemplate(bytes32, string calldata) public virtual;\n\n    function setGuildActive(bytes32, bool) public virtual;\n\n    function guildAdmin(bytes32) public view virtual returns (address);\n\n    function transferGuildAdmin(bytes32, address) public virtual;\n}\n"
    },
    "contracts/ensGuilds/mixins/ENSGuildsToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nabstract contract ENSGuildsToken is ERC1155 {\n    using Counters for Counters.Counter;\n\n    error GuildsTokenTransferNotAllowed();\n\n    uint256 internal constant GUILD_ID_MASK = uint256(~uint128(0)) << 128;\n\n    struct GuildTokenInfo {\n        Counters.Counter tokenIdTracker;\n        string templateURI;\n        mapping(bytes32 => uint256) guildTagsToTokenIds;\n    }\n\n    // maps the top 128 bits of each guild's GuildID (ensNode) to its metadataURI and token ID counter\n    mapping(bytes16 => GuildTokenInfo) private guilds;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155) returns (bool) {\n        return ERC1155.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     * @param tokenId The token whose URI is returned\n     */\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\n        // calculate truncated guildHash from first 128 bits of tokenId\n        uint256 truncatedGuildHashUint = tokenId & GUILD_ID_MASK;\n        bytes16 truncatedGuildHash = bytes16(bytes32(truncatedGuildHashUint));\n\n        // return guild-specific URI if exists\n        string storage guildTemplateURI = guilds[truncatedGuildHash].templateURI;\n        if (bytes(guildTemplateURI).length != 0) {\n            return guildTemplateURI;\n        }\n\n        // return default URI shared by all guilds\n        return ERC1155.uri(tokenId);\n    }\n\n    function _mintNewGuildToken(bytes32 guildHash, bytes32 tagHash, address to) internal {\n        bytes16 truncatedGuildHash = bytes16(guildHash);\n\n        uint256 tokenCounterCurrent = guilds[truncatedGuildHash].tokenIdTracker.current();\n        require(tokenCounterCurrent < type(uint128).max, \"tokenCounterOverflow\");\n\n        guilds[truncatedGuildHash].tokenIdTracker.increment();\n\n        uint256 truncatedGuildHashUint = uint256(guildHash) & GUILD_ID_MASK;\n        uint256 fullTokenId = truncatedGuildHashUint + tokenCounterCurrent;\n\n        bytes memory emptyData;\n        _mint(to, fullTokenId, 1, emptyData);\n\n        guilds[truncatedGuildHash].guildTagsToTokenIds[tagHash] = fullTokenId;\n    }\n\n    function _burnGuildToken(bytes32 guildHash, bytes32 tagHash, address tagOwner) internal {\n        bytes16 truncatedGuildHash = bytes16(guildHash);\n        uint256 tokenId = guilds[truncatedGuildHash].guildTagsToTokenIds[tagHash];\n\n        _burn(tagOwner, tokenId, 1);\n    }\n\n    function _setGuildTokenURITemplate(bytes32 guildHash, string calldata templateURI) internal {\n        bytes16 truncatedGuildHash = bytes16(guildHash);\n        guilds[truncatedGuildHash].templateURI = templateURI;\n    }\n\n    /**\n     * @dev ENSGuilds NFTs are non-transferrable and may only be directly minted and burned\n     * with their corresonding guild tags.\n     */\n    function safeTransferFrom(address, address, uint256, uint256, bytes memory) public virtual override {\n        revert GuildsTokenTransferNotAllowed();\n    }\n}\n"
    },
    "contracts/ensGuilds/mixins/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract ENSResolver is IAddrResolver, IAddressResolver, ERC165 {\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    mapping(bytes32 => address) public addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by descendants of this contract\n     */\n    function _setEnsForwardRecord(bytes32 node, address a) internal {\n        addresses[node] = a;\n        emit AddrChanged(node, a);\n        emit AddressChanged(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * @notice Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public view override returns (address payable) {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function addr(bytes32 node, uint256) public view override returns (bytes memory) {\n        address a = addresses[node];\n        if (a == address(0)) {\n            bytes memory emptyBytes;\n            return emptyBytes;\n        }\n        return addressToBytes(a);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(ERC165) returns (bool) {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    // solhint-disable\n    // Source: https://github.com/ensdomains/ens-contracts/blob/340a6d05cd00d078ae40edbc58c139eb7048189a/contracts/resolvers/profiles/AddrResolver.sol#L85\n    function bytesToAddress(bytes memory b) internal pure returns (address payable a) {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12)) // cspell:disable-line\n        }\n    }\n\n    // Source: https://github.com/ensdomains/ens-contracts/blob/340a6d05cd00d078ae40edbc58c139eb7048189a/contracts/resolvers/profiles/AddrResolver.sol#L96\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12))) // cspell:disable-line\n        }\n    }\n    // solhint-enable\n}\n"
    },
    "contracts/feePolicies/FeePolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title FeePolicy\n * @notice An interface for Guilds to implement that will specify how fees must be paid for guild tag mints\n */\nabstract contract FeePolicy is ERC165 {\n    function supportsInterface(bytes4 interfaceID) public view virtual override(ERC165) returns (bool) {\n        return interfaceID == type(FeePolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /**\n     * @notice Returns the fee required to mint the given guild tag by the given minter\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\n     * @param extraClaimArgs Any additional arguments that would be passed by the minter to the claimGuildTag() function\n     * @return tokenContract The token contract the fee must be paid in (if any). Address(0) designates native Ether.\n     * @return fee The amount (in base unit) that must be paid\n     * @return feePaidTo The address that should receive payment of the fee\n     */\n    function tagClaimFee(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        bytes calldata extraClaimArgs\n    ) external view virtual returns (address tokenContract, uint256 fee, address feePaidTo);\n}\n"
    },
    "contracts/feePolicies/FlatFeePolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./FeePolicy.sol\";\nimport \"../ensGuilds/interfaces/IENSGuilds.sol\";\n\n/**\n * @title FlatFeePolicy\n * @notice A common implementation of FeePolicy that can be used to configure flat-rate fees for multiple guilds simultaneously\n */\ncontract FlatFeePolicy is Context, FeePolicy {\n    using ERC165Checker for address;\n\n    IENSGuilds private ensGuilds;\n    struct FeeInfo {\n        address feeToken;\n        uint256 fee;\n        address feePaidTo;\n    }\n    mapping(bytes32 => FeeInfo) public guildFees;\n\n    constructor(address _ensGuilds) {\n        // solhint-disable-next-line reason-string\n        require(_ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        ensGuilds = IENSGuilds(_ensGuilds);\n    }\n\n    /**\n     * @notice Configures a flat fee for the given guild. The caller must be the guild's admin\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param feeToken The token contract the fee must be paid in (if any). Address(0) designates native Ether.\n     * @param fee The amount (in base unit) that must be paid\n     * @param feePaidTo The address that should receive payment of the fee\n     */\n    function setFlatFee(bytes32 guildHash, address feeToken, uint256 fee, address feePaidTo) external {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(ensGuilds.guildAdmin(guildHash) == _msgSender());\n\n        guildFees[guildHash] = FeeInfo({ feeToken: feeToken, fee: fee, feePaidTo: feePaidTo });\n    }\n\n    /**\n     * @inheritdoc FeePolicy\n     */\n    function tagClaimFee(\n        bytes32 guildHash,\n        bytes32,\n        address,\n        bytes calldata\n    ) external view virtual override returns (address tokenContract, uint256 fee, address feePaidTo) {\n        FeeInfo storage feeInfo = guildFees[guildHash];\n        return (feeInfo.feeToken, feeInfo.fee, feeInfo.feePaidTo);\n    }\n}\n"
    },
    "contracts/libraries/ENSNamehash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Source: https://github.com/JonahGroendal/ens-namehash/blob/master/contracts/ENSNamehash.sol\n\npragma solidity ^0.8.4;\n\n/*\n * @dev Solidity implementation of the ENS namehash algorithm.\n *\n * Warning! Does not normalize or validate names before hashing.\n */\nlibrary ENSNamehash {\n    function namehash(bytes memory domain) internal pure returns (bytes32) {\n        return namehash(domain, 0);\n    }\n\n    function namehash(bytes memory domain, uint i) internal pure returns (bytes32) {\n        if (domain.length <= i) return 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n        uint len = LabelLength(domain, i);\n\n        return keccak256(abi.encodePacked(namehash(domain, i + len + 1), keccak(domain, i, len)));\n    }\n\n    function LabelLength(bytes memory domain, uint i) private pure returns (uint) {\n        uint len;\n        while (i + len != domain.length && domain[i + len] != 0x2e) {\n            len++;\n        }\n        return len;\n    }\n\n    function keccak(bytes memory data, uint offset, uint len) private pure returns (bytes32 ret) {\n        require(offset + len <= data.length);\n        assembly {\n            ret := keccak256(add(add(data, 32), offset), len)\n        }\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/AllowlistTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BaseTagsAuthPolicy.sol\";\n\ncontract AllowlistTagsAuthPolicy is BaseTagsAuthPolicy {\n    mapping(bytes32 => mapping(address => bool)) public guildAllowlists;\n\n    constructor(IENSGuilds ensGuilds) BaseTagsAuthPolicy(ensGuilds) {}\n\n    function allowMint(bytes32 guildHash, address minter) external {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(_ensGuilds.guildAdmin(guildHash) == _msgSender());\n        guildAllowlists[guildHash][minter] = true;\n    }\n\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata\n    ) external virtual override returns (bool) {\n        return guildAllowlists[guildHash][claimant];\n    }\n\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata\n    ) internal virtual override returns (bytes32 tagToRevoke) {\n        guildAllowlists[guildHash][claimant] = false;\n        return 0;\n    }\n\n    function tagCanBeRevoked(address, bytes32, bytes32, bytes calldata) external virtual override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/BaseTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./ITagsAuthPolicy.sol\";\nimport \"../ensGuilds/interfaces/IENSGuilds.sol\";\n\n/**\n * @title BaseTagsAuthPolicy\n * @notice An base implementation of ITagsAuthPolicy\n */\nabstract contract BaseTagsAuthPolicy is ITagsAuthPolicy, ERC165, Context, ReentrancyGuard {\n    using ERC165Checker for address;\n\n    IENSGuilds internal _ensGuilds;\n\n    constructor(IENSGuilds ensGuilds) {\n        require(ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        _ensGuilds = ensGuilds;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev protects against reentrancy and checks that caller is the Guilds contract\n     */\n    function onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external override nonReentrant returns (bytes32 tagToRevoke) {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(_msgSender() == address(_ensGuilds));\n\n        return _onTagClaimed(guildHash, tagHash, claimant, recipient, extraClaimArgs);\n    }\n\n    /**\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy\n     */\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) internal virtual returns (bytes32 tagToRevoke);\n}\n"
    },
    "contracts/tagsAuthPolicies/ITagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title TagsAuthPolicy\n * @notice An interface for Guilds to implement that will control authorization for minting tags within that guild\n */\ninterface ITagsAuthPolicy is IERC165 {\n    /**\n     * @notice Checks whether a certain address (claimant) may claim a given guild tag\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\n     * @param recipient The address that would receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     */\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external returns (bool);\n\n    /**\n     * @dev Called by ENSGuilds once a tag has been claimed.\n     * Provided for auth policies to update local state, such as erasing an address from an allowlist after that\n     * address has successfully minted a tag.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param claimant The address that claimed the tag (not necessarily the address that received it)\n     * @param recipient The address that received receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     */\n    function onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external returns (bytes32 tagToRevoke);\n\n    /**\n     * @notice Checks whether a given guild tag is elligible to be revoked\n     * @param revokedBy The address that would attempt to revoke it\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param extraRevokeArgs Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function tagCanBeRevoked(\n        address revokedBy,\n        bytes32 guildHash,\n        bytes32 tagHash,\n        bytes calldata extraRevokeArgs\n    ) external returns (bool);\n}\n"
    },
    "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"./BaseTagsAuthPolicy.sol\";\n\ncontract NFTTagsAuthPolicy is BaseTagsAuthPolicy {\n    using ERC165Checker for address;\n\n    enum TokenStandard {\n        ERC721,\n        ERC1155\n    }\n    struct TagClaim {\n        bytes32 tagHash;\n        address claimedBy;\n    }\n    struct GuildInfo {\n        address tokenContract;\n        TokenStandard tokenStandard;\n        mapping(uint256 => TagClaim) tagClaims;\n    }\n    mapping(bytes32 => GuildInfo) public guilds;\n\n    constructor(IENSGuilds ensGuilds) BaseTagsAuthPolicy(ensGuilds) {}\n\n    function setTokenContract(bytes32 guildHash, address tokenContract) external {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(_ensGuilds.guildAdmin(guildHash) == _msgSender());\n\n        // token contract must be ERC721 or ERC1155\n        if (tokenContract.supportsInterface(type(IERC721).interfaceId)) {\n            guilds[guildHash].tokenStandard = TokenStandard.ERC721;\n        } else if (tokenContract.supportsInterface(type(IERC1155).interfaceId)) {\n            guilds[guildHash].tokenStandard = TokenStandard.ERC1155;\n        } else {\n            // solhint-disable-next-line reason-string\n            revert();\n        }\n\n        guilds[guildHash].tokenContract = tokenContract;\n    }\n\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) external virtual override returns (bool) {\n        GuildInfo storage guildInfo = guilds[guildHash];\n        address tokenContract = guildInfo.tokenContract;\n\n        // parse NFT token ID from the tag claim args\n        if (extraClaimArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        // check that claimant owns this NFT\n        bool ownsNFT = false;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            ownsNFT = IERC721(tokenContract).ownerOf(nftTokenId) == claimant;\n        } else {\n            ownsNFT = IERC1155(tokenContract).balanceOf(claimant, nftTokenId) > 0;\n        }\n        if (!ownsNFT) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) internal virtual override returns (bytes32 tagToRevoke) {\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        tagToRevoke = guilds[guildHash].tagClaims[nftTokenId].tagHash;\n\n        guilds[guildHash].tagClaims[nftTokenId].tagHash = tagHash;\n        guilds[guildHash].tagClaims[nftTokenId].claimedBy = claimant;\n\n        return tagToRevoke;\n    }\n\n    function tagCanBeRevoked(\n        address,\n        bytes32 guildHash,\n        bytes32 tagHash,\n        bytes calldata extraRevokeArgs\n    ) external virtual override returns (bool) {\n        if (extraRevokeArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraRevokeArgs));\n\n        GuildInfo storage guildInfo = guilds[guildHash];\n        address tokenContract = guildInfo.tokenContract;\n\n        // check that the given tag was indeed claimed from the given NFT\n        if (guildInfo.tagClaims[nftTokenId].tagHash != tagHash) {\n            return false;\n        }\n\n        // check that the current owner of the given NFT is the same as the owner when the tag was claimed\n        address previousClaimant = guildInfo.tagClaims[nftTokenId].claimedBy;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            address currentTokenOwner = IERC721(tokenContract).ownerOf(nftTokenId);\n            return currentTokenOwner != previousClaimant;\n        } else {\n            return IERC1155(tokenContract).balanceOf(previousClaimant, nftTokenId) == 0;\n        }\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/OpenTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./ITagsAuthPolicy.sol\";\n\ncontract OpenTagsAuthPolicy is ITagsAuthPolicy, ERC165 {\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function canClaimTag(bytes32, bytes32, address, address, bytes calldata) external virtual override returns (bool) {\n        return true;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        bytes32,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (bytes32 tagToRevoke) {\n        return 0;\n    }\n\n    function tagCanBeRevoked(address, bytes32, bytes32, bytes calldata) external virtual override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/ClaimGuildTagReentrancyAttacker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../ensGuilds/interfaces/IENSGuilds.sol\";\nimport \"./IClaimGuildTagReentrancyAttacker.sol\";\n\n/**\n * ClaimGuildTagReentrancyAttacker is a contract that exposes an apparently\n * benign lookup function that will re-invoke `claimGuildTag`.\n */\ncontract ClaimGuildTagReentrancyAttacker is IClaimGuildTagReentrancyAttacker {\n    IENSGuilds private ensGuilds;\n\n    bytes32 private guildEnsNode;\n    bytes32 private tagHash;\n    address private recipient;\n    bytes private extraClaimArgs;\n\n    constructor(\n        IENSGuilds _ensGuilds,\n        bytes32 _guildEnsNode,\n        bytes32 _tagHash,\n        address _recipient,\n        bytes memory _extraClaimArgs\n    ) {\n        ensGuilds = _ensGuilds;\n\n        guildEnsNode = _guildEnsNode;\n        tagHash = _tagHash;\n        recipient = _recipient;\n        extraClaimArgs = _extraClaimArgs;\n    }\n\n    function insidiousLookupFunction() external override returns (bool) {\n        ensGuilds.claimGuildTag(guildEnsNode, tagHash, recipient, extraClaimArgs);\n        return true;\n    }\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/IClaimGuildTagReentrancyAttacker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IClaimGuildTagReentrancyAttacker {\n    function insidiousLookupFunction() external returns (bool);\n}\n"
    },
    "contracts/testHelpers/claimTagAuthzReentrancyAttack/ReentrancyAttackAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"../../tagsAuthPolicies/ITagsAuthPolicy.sol\";\nimport \"./IClaimGuildTagReentrancyAttacker.sol\";\n\n/**\n * ReentrancyAttackAuthPolicy is a dummy TagsAuthPolicy that includes logic in\n * its `canClaimTag` implementation that calls out to a function on a\n * separate contract.\n *\n * That separate contract exposes an apparently benign lookup function that\n * will re-invoke `claimGuildTag`.\n */\ncontract ReentrancyAttackAuthPolicy is ITagsAuthPolicy, ERC165 {\n    IClaimGuildTagReentrancyAttacker private attacker;\n\n    constructor(IClaimGuildTagReentrancyAttacker _attacker) {\n        attacker = _attacker;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function canClaimTag(bytes32, bytes32, address, address, bytes calldata) external virtual override returns (bool) {\n        bool canMint = attacker.insidiousLookupFunction();\n        return canMint;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        bytes32,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (bytes32 tagToRevoke) {\n        return bytes32(0);\n    }\n\n    function tagCanBeRevoked(address, bytes32, bytes32, bytes calldata) external virtual override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/testHelpers/RevocationTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"../tagsAuthPolicies/ITagsAuthPolicy.sol\";\n\ncontract RevocationTestHelper is ITagsAuthPolicy, ERC165 {\n    bytes32 private _onTagClaimedRetVal;\n    bool private _tagCanBeRevokedRetVal = true;\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    function canClaimTag(bytes32, bytes32, address, address, bytes calldata) external virtual override returns (bool) {\n        return true;\n    }\n\n    function onTagClaimed(\n        bytes32,\n        bytes32,\n        address,\n        address,\n        bytes calldata\n    ) external virtual override returns (bytes32 tagToRevoke) {\n        return _onTagClaimedRetVal;\n    }\n\n    function tagCanBeRevoked(address, bytes32, bytes32, bytes calldata) external virtual override returns (bool) {\n        return _tagCanBeRevokedRetVal;\n    }\n\n    function stub_tagCanBeRevokedReturnVal(bool retVal) external {\n        _tagCanBeRevokedRetVal = retVal;\n    }\n\n    function stub_onTagClaimedReturnVal(bytes32 retVal) external {\n        _onTagClaimedRetVal = retVal;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    }
  }
}
