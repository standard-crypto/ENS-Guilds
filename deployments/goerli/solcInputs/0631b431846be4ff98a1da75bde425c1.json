{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(bytes32 node, uint256 coinType)\n        external\n        view\n        returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ensGuilds/interfaces/IENSGuilds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\";\n\ninterface IENSGuilds is IAddrResolver, IAddressResolver, IERC1155MetadataURI {\n    /** Events */\n    event Registered(bytes32 indexed guildHash);\n    event Deregistered(bytes32 indexed guildHash);\n    event TagClaimed(bytes32 indexed guildId, bytes32 indexed tagHash, address recipient);\n    event TagRevoked(bytes32 indexed guildId, bytes32 indexed tagHash);\n    event FeePolicyUpdated(bytes32 indexed guildId, address feePolicy);\n    event TagsAuthPolicyUpdated(bytes32 indexed guildId, address tagsAuthPolicy);\n    event AdminTransferred(bytes32 indexed guildId, address newAdmin);\n    event SetActive(bytes32 indexed guildId, bool active);\n    event TokenUriTemplateSet(bytes32 indexed guildId, string uriTemplate);\n\n    /* Functions */\n\n    /**\n     * @notice Registers a new guild from an existing ENS domain.\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \"operator\" for the caller.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param guildAdmin The address that will administrate this guild\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function registerGuild(bytes32 guildHash, address guildAdmin, address feePolicy, address tagsAuthPolicy) external;\n\n    /**\n     * @notice Deregisters a registered guild.\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\n     * @param guildHash The ENS namehash of the guild's domain\n     */\n    function deregisterGuild(bytes32 guildHash) external;\n\n    /**\n     * @notice Claims a guild tag\n     * @param guildHash The namehash of the guild for which the tag should be claimed (e.g. namehash('my-guild.eth'))\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\n     *  such as authorization\n     */\n    function claimGuildTag(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Claims multiple tags for a guild at once\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHashes Namehashes of each tag to be claimed\n     * @param recipients Recipients of each tag to be claimed\n     * @param extraClaimArgs Per-tag extra arguments required for guild-specific logic, such as authorization.\n     * Must have same length as array of tagHashes, even if each array element is itself empty bytes\n     */\n    function claimGuildTagsBatch(\n        bytes32 guildHash,\n        bytes32[] calldata tagHashes,\n        address[] calldata recipients,\n        bytes[] calldata extraClaimArgs\n    ) external payable;\n\n    /**\n     * @notice Returns the current owner of the given guild tag.\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\n     */\n    function tagOwner(bytes32 guildHash, bytes32 tagHash) external view returns (address);\n\n    /**\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTag(bytes32 guildHash, bytes32 tagHash, bytes calldata extraData) external;\n\n    /**\n     * @notice Attempts to revoke multiple guild tags\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHashes ENS namehashes of all tags to revoke\n     * @param extraData Additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function revokeGuildTagsBatch(bytes32 guildHash, bytes32[] calldata tagHashes, bytes[] calldata extraData) external;\n\n    /**\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\n     */\n    function updateGuildFeePolicy(bytes32 guildHash, address feePolicy) external;\n\n    /**\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagsAuthPolicy The address of an implementaition of TagsAuthPolicy to use for minting new tags within this guild\n     */\n    function updateGuildTagsAuthPolicy(bytes32 guildHash, address tagsAuthPolicy) external;\n\n    /**\n     * @notice Sets the metadata URI template string for fetching metadata for a guild's tag NFTs.\n     * May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param uriTemplate The ERC1155 metadata URL template\n     */\n    function setGuildTokenUriTemplate(bytes32 guildHash, string calldata uriTemplate) external;\n\n    /**\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param active The new status\n     */\n    function setGuildActive(bytes32 guildHash, bool active) external;\n\n    /**\n     * @notice Returns the current admin registered for the given guild.\n     * @param guildHash The ENS namehash of the guild's domain\n     */\n    function guildAdmin(bytes32 guildHash) external view returns (address);\n\n    /**\n     * @notice Transfers the role of guild admin to the given address. May only be called by the guild's registered admin.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param newAdmin The new admin\n     */\n    function transferGuildAdmin(bytes32 guildHash, address newAdmin) external;\n}\n"
    },
    "contracts/tagsAuthPolicies/AllowlistTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./BaseTagsAuthPolicy.sol\";\n\n/**\n * @title AllowlistTagsAuthPolicy\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only allowlisted addresses.\n * A separate allowlist is maintained per each guild, and may only be updated by that guild's registered admin.\n */\ncontract AllowlistTagsAuthPolicy is BaseTagsAuthPolicy {\n    mapping(bytes32 => mapping(address => bool)) public guildAllowlists;\n\n    constructor(IENSGuilds ensGuilds) BaseTagsAuthPolicy(ensGuilds) {}\n\n    modifier onlyGuildAdmin(bytes32 guildHash) {\n        // solhint-disable-next-line reason-string\n        require(_ensGuilds.guildAdmin(guildHash) == _msgSender());\n        _;\n    }\n\n    function allowMint(bytes32 guildHash, address minter) external onlyGuildAdmin(guildHash) {\n        guildAllowlists[guildHash][minter] = true;\n    }\n\n    function disallowMint(bytes32 guildHash, address minter) external onlyGuildAdmin(guildHash) {\n        guildAllowlists[guildHash][minter] = false;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata\n    ) external virtual override returns (bool) {\n        return guildAllowlists[guildHash][claimant];\n    }\n\n    /**\n     * @dev removes the claimant from the guild's allowlist\n     */\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata\n    ) internal virtual override returns (bytes32 tagToRevoke) {\n        guildAllowlists[guildHash][claimant] = false;\n        return 0;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function tagCanBeRevoked(address, bytes32, bytes32, bytes calldata) external virtual override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/tagsAuthPolicies/BaseTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./ITagsAuthPolicy.sol\";\nimport \"../ensGuilds/interfaces/IENSGuilds.sol\";\n\n/**\n * @title BaseTagsAuthPolicy\n * @notice An base implementation of ITagsAuthPolicy\n */\nabstract contract BaseTagsAuthPolicy is ITagsAuthPolicy, ERC165, Context, ReentrancyGuard {\n    using ERC165Checker for address;\n\n    IENSGuilds internal _ensGuilds;\n\n    constructor(IENSGuilds ensGuilds) {\n        require(ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\n        _ensGuilds = ensGuilds;\n    }\n\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\n     * is deferred to the implementation.\n     */\n    function onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external override nonReentrant returns (bytes32 tagToRevoke) {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(_msgSender() == address(_ensGuilds));\n\n        return _onTagClaimed(guildHash, tagHash, claimant, recipient, extraClaimArgs);\n    }\n\n    /**\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\n     */\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) internal virtual returns (bytes32 tagToRevoke);\n}\n"
    },
    "contracts/tagsAuthPolicies/ITagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title TagsAuthPolicy\n * @notice An interface for Guilds to implement that will control authorization for minting tags within that guild\n */\ninterface ITagsAuthPolicy is IERC165 {\n    /**\n     * @notice Checks whether a certain address (claimant) may claim a given guild tag\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\n     * @param recipient The address that would receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     */\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external returns (bool);\n\n    /**\n     * @dev Called by ENSGuilds once a tag has been claimed.\n     * Provided for auth policies to update local state, such as erasing an address from an allowlist after that\n     * address has successfully minted a tag.\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param claimant The address that claimed the tag (not necessarily the address that received it)\n     * @param recipient The address that received receive the tag\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\n     */\n    function onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address recipient,\n        bytes calldata extraClaimArgs\n    ) external returns (bytes32 tagToRevoke);\n\n    /**\n     * @notice Checks whether a given guild tag is elligible to be revoked\n     * @param revokedBy The address that would attempt to revoke it\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tagHash The ENS namehash of the tag being claimed (e.g. keccak256('foo') for foo.my-guild.eth)\n     * @param extraRevokeArgs Any additional arguments necessary for assessing whether a tag may be revoked\n     */\n    function tagCanBeRevoked(\n        address revokedBy,\n        bytes32 guildHash,\n        bytes32 tagHash,\n        bytes calldata extraRevokeArgs\n    ) external returns (bool);\n}\n"
    },
    "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"./BaseTagsAuthPolicy.sol\";\n\n/**\n * @title NFTTagsAuthPolicy\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses\n * that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once\n * per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being\n * revoked once the second is minted, regardless of whether ownership of that TokenID has changed.\n *\n * A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\n */\ncontract NFTTagsAuthPolicy is BaseTagsAuthPolicy {\n    using ERC165Checker for address;\n\n    enum TokenStandard {\n        ERC721,\n        ERC1155\n    }\n    struct TagClaim {\n        bytes32 tagHash;\n        address claimedBy;\n    }\n    struct GuildInfo {\n        address tokenContract;\n        TokenStandard tokenStandard;\n        mapping(uint256 => TagClaim) tagClaims;\n    }\n    mapping(bytes32 => GuildInfo) public guilds;\n\n    constructor(IENSGuilds ensGuilds) BaseTagsAuthPolicy(ensGuilds) {}\n\n    /**\n     * Registers the specific NFT collection that a user must be a member of to mint a guild tag\n     * @param guildHash The ENS namehash of the guild's domain\n     * @param tokenContract The ERC721 or ERC1155 collection to use\n     */\n    function setTokenContract(bytes32 guildHash, address tokenContract) external {\n        // caller must be guild admin\n        // solhint-disable-next-line reason-string\n        require(_ensGuilds.guildAdmin(guildHash) == _msgSender());\n\n        // token contract must be ERC721 or ERC1155\n        if (tokenContract.supportsInterface(type(IERC721).interfaceId)) {\n            guilds[guildHash].tokenStandard = TokenStandard.ERC721;\n        } else if (tokenContract.supportsInterface(type(IERC1155).interfaceId)) {\n            guilds[guildHash].tokenStandard = TokenStandard.ERC1155;\n        } else {\n            // solhint-disable-next-line reason-string\n            revert();\n        }\n\n        guilds[guildHash].tokenContract = tokenContract;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     * @dev Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`.\n     * The caller must own the given TokenID.\n     */\n    function canClaimTag(\n        bytes32 guildHash,\n        bytes32,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) external virtual override returns (bool) {\n        GuildInfo storage guildInfo = guilds[guildHash];\n        address tokenContract = guildInfo.tokenContract;\n\n        // parse NFT token ID from the tag claim args\n        if (extraClaimArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        // check that claimant owns this NFT\n        bool ownsNFT = false;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            ownsNFT = IERC721(tokenContract).ownerOf(nftTokenId) == claimant;\n        } else {\n            ownsNFT = IERC1155(tokenContract).balanceOf(claimant, nftTokenId) > 0;\n        }\n        if (!ownsNFT) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev records the latest tag minted from the given TokenID (via extraClaimArgs), and returns whichever\n     * tag was last minted from the same TokenID.\n     */\n    function _onTagClaimed(\n        bytes32 guildHash,\n        bytes32 tagHash,\n        address claimant,\n        address,\n        bytes calldata extraClaimArgs\n    ) internal virtual override returns (bytes32 tagToRevoke) {\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\n\n        tagToRevoke = guilds[guildHash].tagClaims[nftTokenId].tagHash;\n\n        guilds[guildHash].tagClaims[nftTokenId].tagHash = tagHash;\n        guilds[guildHash].tagClaims[nftTokenId].claimedBy = claimant;\n\n        return tagToRevoke;\n    }\n\n    /**\n     * @inheritdoc ITagsAuthPolicy\n     */\n    function tagCanBeRevoked(\n        address,\n        bytes32 guildHash,\n        bytes32 tagHash,\n        bytes calldata extraRevokeArgs\n    ) external virtual override returns (bool) {\n        if (extraRevokeArgs.length != 32) {\n            return false;\n        }\n        uint256 nftTokenId = uint256(bytes32(extraRevokeArgs));\n\n        GuildInfo storage guildInfo = guilds[guildHash];\n        address tokenContract = guildInfo.tokenContract;\n\n        // check that the given tag was indeed claimed from the given NFT\n        if (guildInfo.tagClaims[nftTokenId].tagHash != tagHash) {\n            return false;\n        }\n\n        // check that the current owner of the given NFT is the same as the owner when the tag was claimed\n        address previousClaimant = guildInfo.tagClaims[nftTokenId].claimedBy;\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\n            address currentTokenOwner = IERC721(tokenContract).ownerOf(nftTokenId);\n            return currentTokenOwner != previousClaimant;\n        } else {\n            return IERC1155(tokenContract).balanceOf(previousClaimant, nftTokenId) == 0;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    }
  }
}
