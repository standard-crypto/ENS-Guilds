{
  "address": "0x76aFF3369840C9aB0B1459216610571e31742dE3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IENSGuilds",
          "name": "ensGuilds",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "TokenIDTagMustMatchCallerTokenID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "claimant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "extraClaimArgs",
          "type": "bytes"
        }
      ],
      "name": "canClaimTag",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "guilds",
      "outputs": [
        {
          "internalType": "address",
          "name": "tokenContract",
          "type": "address"
        },
        {
          "internalType": "enum NFTTagsAuthPolicy.TokenStandard",
          "name": "tokenStandard",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "claimant",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "extraClaimArgs",
          "type": "bytes"
        }
      ],
      "name": "onTagClaimed",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "tagToRevoke",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "guildHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "tokenContract",
          "type": "address"
        }
      ],
      "name": "setTokenContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceID",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "guildHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "tag",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "extraRevokeArgs",
          "type": "bytes"
        }
      ],
      "name": "tagCanBeRevoked",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0313656ee2644119912e1bd7868954048a36e5d10fe21435289cd556db7fc05f",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xE72285aee8Ad0b545DD6287Aab9EbE8237D4e7Cf",
    "contractAddress": null,
    "transactionIndex": 41,
    "gasUsed": "797833",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1cae7762b860c03db7a5038ff3a3443792ac6d348b02a17b6cc102bef71c29e3",
    "transactionHash": "0x0313656ee2644119912e1bd7868954048a36e5d10fe21435289cd556db7fc05f",
    "logs": [],
    "blockNumber": 9284156,
    "cumulativeGasUsed": "7225076",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xac0C325fDc7af8ce362E7b565e908BCc8AB4C821"
  ],
  "numDeployments": 1,
  "solcInputHash": "b97570d84b48e6434b4ee0064c5f38b2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IENSGuilds\",\"name\":\"ensGuilds\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TokenIDTagMustMatchCallerTokenID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraClaimArgs\",\"type\":\"bytes\"}],\"name\":\"canClaimTag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"guilds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"enum NFTTagsAuthPolicy.TokenStandard\",\"name\":\"tokenStandard\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extraClaimArgs\",\"type\":\"bytes\"}],\"name\":\"onTagClaimed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"tagToRevoke\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"guildHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"guildHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"extraRevokeArgs\",\"type\":\"bytes\"}],\"name\":\"tagCanBeRevoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"canClaimTag(bytes32,string,address,address,bytes)\":{\"details\":\"Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`. The caller must own the given TokenID.\",\"params\":{\"claimant\":\"The address attempting to claim the tag (not necessarily the address that will receive it)\",\"extraClaimArgs\":\"[Optional] Any guild-specific additional arguments required\",\"guildHash\":\"The ENS namehash of the guild's domain\",\"recipient\":\"The address that would receive the tag\",\"tag\":\"The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\"}},\"onTagClaimed(bytes32,string,address,address,bytes)\":{\"details\":\"protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.\",\"params\":{\"claimant\":\"The address that claimed the tag (not necessarily the address that received it)\",\"extraClaimArgs\":\"[Optional] Any guild-specific additional arguments required\",\"guildHash\":\"The ENS namehash of the guild's domain\",\"recipient\":\"The address that received receive the tag\",\"tag\":\"The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\"},\"returns\":{\"tagToRevoke\":\"The ENS namehash of any tag that should be revoked as a consequence of the given tag being claimed. Returns zero if no tag should be revoked.\"}},\"setTokenContract(bytes32,address)\":{\"params\":{\"guildHash\":\"The ENS namehash of the guild's domain\",\"tokenContract\":\"The ERC721 or ERC1155 collection to use\"}},\"tagCanBeRevoked(address,bytes32,string,bytes)\":{\"params\":{\"extraRevokeArgs\":\"Any additional arguments necessary for assessing whether a tag may be revoked\",\"guildHash\":\"The ENS namehash of the guild's domain\",\"revokedBy\":\"The address that would attempt to revoke it\",\"tag\":\"The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\"}}},\"title\":\"NFTTagsAuthPolicy\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"canClaimTag(bytes32,string,address,address,bytes)\":{\"notice\":\"Checks whether a certain address (claimant) may claim a given guild tag\"},\"setTokenContract(bytes32,address)\":{\"notice\":\"Registers the specific NFT collection that a user must be a member of to mint a guild tag\"},\"tagCanBeRevoked(address,bytes32,string,bytes)\":{\"notice\":\"Checks whether a given guild tag is eligible to be revoked\"}},\"notice\":\"A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being revoked once the second is minted, regardless of whether ownership of that TokenID has changed. A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol\":\"NFTTagsAuthPolicy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the legacy (ETH-only) addr function.\\n */\\ninterface IAddrResolver {\\n    event AddrChanged(bytes32 indexed node, address a);\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) external view returns (address payable);\\n}\\n\",\"keccak256\":\"0x2ad7f2fc60ebe0f93745fe70247f6a854f66af732483fda2a3c5e055614445e8\",\"license\":\"MIT\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/**\\n * Interface for the new (multicoin) addr function.\\n */\\ninterface IAddressResolver {\\n    event AddressChanged(\\n        bytes32 indexed node,\\n        uint256 coinType,\\n        bytes newAddress\\n    );\\n\\n    function addr(\\n        bytes32 node,\\n        uint256 coinType\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x411447c1e90c51e09702815a85ec725ffbbe37cf96e8cc4d2a8bd4ad8a59d73e\",\"license\":\"MIT\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IExtendedResolver {\\n    function resolve(\\n        bytes memory name,\\n        bytes memory data\\n    ) external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5d81521cfae7d9a4475d27533cd8ed0d3475d369eb0674fd90ffbdbdf292faa3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xa535a5df777d44e945dd24aa43a11e44b024140fc340ad0dfe42acf4002aade1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcab667ddad478ff0d39c2053ca77fac778af8483c18ab07d810277b4216fd582\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa66d18b9a85458d28fc3304717964502ae36f7f8a2ff35bc83f6f85d74b03574\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5a08ad61f4e82b8a3323562661a86fb10b10190848073fdc13d4ac43710ffba5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/ensGuilds/interfaces/IENSGuilds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\\\";\\nimport \\\"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\\\";\\n\\ninterface IENSGuilds is IAddrResolver, IAddressResolver, IERC1155MetadataURI {\\n    /** Events */\\n    event Registered(bytes32 indexed guildEnsNode);\\n    event Deregistered(bytes32 indexed guildEnsNode);\\n    event TagClaimed(bytes32 indexed guildId, bytes32 indexed tagHash, address recipient);\\n    event TagRevoked(bytes32 indexed guildId, bytes32 indexed tagHash);\\n    event FeePolicyUpdated(bytes32 indexed guildId, address feePolicy);\\n    event TagsAuthPolicyUpdated(bytes32 indexed guildId, address tagsAuthPolicy);\\n    event AdminTransferred(bytes32 indexed guildId, address newAdmin);\\n    event SetActive(bytes32 indexed guildId, bool active);\\n    event TokenUriTemplateSet(bytes32 indexed guildId, string uriTemplate);\\n\\n    /* Functions */\\n\\n    /**\\n     * @notice Registers a new guild from an existing ENS domain.\\n     * Caller must be the ENS node's owner and ENSGuilds must have been designated an \\\"operator\\\" for the caller.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param guildAdmin The address that will administrate this guild\\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for minting new tags\\n     * within this guild\\n     */\\n    function registerGuild(\\n        bytes32 guildEnsNode,\\n        address guildAdmin,\\n        address feePolicy,\\n        address tagsAuthPolicy\\n    ) external;\\n\\n    /**\\n     * @notice De-registers a registered guild.\\n     * Designates guild as inactive and marks all tags previously minted for that guild as eligible for revocation.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     */\\n    function deregisterGuild(bytes32 guildEnsNode) external;\\n\\n    /**\\n     * @notice Claims a guild tag\\n     * @param guildEnsNode The namehash of the guild for which the tag should be claimed (e.g. namehash('my-guild.eth'))\\n     * @param tag The tag name to claim (e.g. 'foo' for foo.my-guild.eth). Assumes `tag` is already normalized per\\n     *            ENS Name Processing rules\\n     * @param recipient The address that will receive this guild tag (usually same as the caller)\\n     * @param extraClaimArgs [Optional] Any additional arguments necessary for guild-specific logic,\\n     *  such as authorization\\n     */\\n    function claimGuildTag(\\n        bytes32 guildEnsNode,\\n        string calldata tag,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external payable;\\n\\n    /**\\n     * @notice Claims multiple tags for a guild at once\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tags Tags to be claimed\\n     * @param recipients Recipients of each tag to be claimed\\n     * @param extraClaimArgs Per-tag extra arguments required for guild-specific logic, such as authorization.\\n     * Must have same length as array of tagHashes, even if each array element is itself empty bytes\\n     */\\n    function claimGuildTagsBatch(\\n        bytes32 guildEnsNode,\\n        string[] calldata tags,\\n        address[] calldata recipients,\\n        bytes[] calldata extraClaimArgs\\n    ) external payable;\\n\\n    /**\\n     * @notice Returns the current owner of the given guild tag.\\n     * Returns address(0) if no such guild or tag exists, or if the guild has been deregistered.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tagHash The ENS namehash of the tag (e.g. keccak256('foo') for foo.my-guild.eth)\\n     */\\n    function tagOwner(bytes32 guildEnsNode, bytes32 tagHash) external view returns (address);\\n\\n    /**\\n     * @notice Attempts to revoke an existing guild tag, if authorized by the guild's AuthPolicy.\\n     * Deregistered guilds will bypass auth checks for revocation of all tags.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tag The tag to revoke\\n     * @param extraData [Optional] Any additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function revokeGuildTag(bytes32 guildEnsNode, string calldata tag, bytes calldata extraData) external;\\n\\n    /**\\n     * @notice Attempts to revoke multiple guild tags\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tagHashes ENS namehashes of all tags to revoke\\n     * @param extraData Additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function revokeGuildTagsBatch(\\n        bytes32 guildEnsNode,\\n        string[] calldata tagHashes,\\n        bytes[] calldata extraData\\n    ) external;\\n\\n    /**\\n     * @notice Updates the FeePolicy for an existing guild. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param feePolicy The address of an implementation of FeePolicy to use for minting new tags within this guild\\n     */\\n    function updateGuildFeePolicy(bytes32 guildEnsNode, address feePolicy) external;\\n\\n    /**\\n     * @notice Updates the TagsAuthPolicy for an existing guild. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param tagsAuthPolicy The address of an implementation of TagsAuthPolicy to use for\\n     * minting new tags within this guild\\n     */\\n    function updateGuildTagsAuthPolicy(bytes32 guildEnsNode, address tagsAuthPolicy) external;\\n\\n    /**\\n     * @notice Sets the metadata URI template string for fetching metadata for a guild's tag NFTs.\\n     * May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param uriTemplate The ERC1155 metadata URL template\\n     */\\n    function setGuildTokenUriTemplate(bytes32 guildEnsNode, string calldata uriTemplate) external;\\n\\n    /**\\n     * @notice Sets a guild as active or inactive. May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param active The new status\\n     */\\n    function setGuildActive(bytes32 guildEnsNode, bool active) external;\\n\\n    /**\\n     * @notice Returns the current admin registered for the given guild.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     */\\n    function guildAdmin(bytes32 guildEnsNode) external view returns (address);\\n\\n    /**\\n     * @notice Transfers the role of guild admin to the given address.\\n     * May only be called by the guild's registered admin.\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     * @param newAdmin The new admin\\n     */\\n    function transferGuildAdmin(bytes32 guildEnsNode, address newAdmin) external;\\n\\n    /**\\n     * @notice Registers a resolver for the guild's root ENS name that will\\n     * dynamically resolve the guild's child names\\n     * @param guildEnsNode The ENS namehash of the guild's domain\\n     */\\n    function setWildcardResolver(bytes32 guildEnsNode, IExtendedResolver wildcardResolver) external;\\n}\\n\",\"keccak256\":\"0xbf5f67d8b52bf4aabbc3451d90cd261e2cb9cf9b7bcd9a2da18833fd929fb7c4\",\"license\":\"MIT\"},\"contracts/libraries/StringParsing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary StringParsing {\\n    /**\\n     * @dev Parses a UTF8 string of digits representing an unsigned integer.\\n     */\\n    function parseUint256(bytes calldata b) internal pure returns (bool valid, uint256 parsed) {\\n        uint i;\\n        parsed = 0;\\n        for (i = 0; i < b.length; i++) {\\n            if (b[i] < bytes1(0x30) || b[i] > bytes1(0x39)) {\\n                return (false, 0);\\n            }\\n            uint c = uint(uint8(b[i])) - 48;\\n            parsed = parsed * 10 + c;\\n        }\\n        return (true, parsed);\\n    }\\n}\\n\",\"keccak256\":\"0x30416dd73951b1eef45e81e0221e9165e33d7e5b6145dee874b174cf44f37317\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/BaseTagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./ITagsAuthPolicy.sol\\\";\\nimport \\\"../ensGuilds/interfaces/IENSGuilds.sol\\\";\\n\\n/**\\n * @title BaseTagsAuthPolicy\\n * @notice An base implementation of ITagsAuthPolicy\\n */\\nabstract contract BaseTagsAuthPolicy is ITagsAuthPolicy, ERC165, Context, ReentrancyGuard {\\n    using ERC165Checker for address;\\n\\n    IENSGuilds internal immutable _ensGuilds;\\n\\n    constructor(IENSGuilds ensGuilds) {\\n        // solhint-disable-next-line reason-string\\n        require(ensGuilds.supportsInterface(type(IENSGuilds).interfaceId));\\n        _ensGuilds = ensGuilds;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceID == type(ITagsAuthPolicy).interfaceId || super.supportsInterface(interfaceID);\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev protects against reentrancy and checks that caller is the Guilds contract. Updating any state\\n     * is deferred to the implementation.\\n     */\\n    function onTagClaimed(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external override nonReentrant returns (bytes32 tagToRevoke) {\\n        // caller must be guild admin\\n        // solhint-disable-next-line reason-string\\n        require(_msgSender() == address(_ensGuilds));\\n\\n        return _onTagClaimed(guildHash, tag, claimant, recipient, extraClaimArgs);\\n    }\\n\\n    /**\\n     * @dev entrypoint for implementations of BaseTagsAuthPolicy that need to update any state\\n     */\\n    function _onTagClaimed(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) internal virtual returns (bytes32 tagToRevoke);\\n}\\n\",\"keccak256\":\"0xe4f631149c8708b55e337dcbc75eed7e50f46b525ba6351aec5147b6c69917e0\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/ITagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title TagsAuthPolicy\\n * @notice An interface for Guilds to implement that will control authorization for minting tags within that guild\\n */\\ninterface ITagsAuthPolicy is IERC165 {\\n    /**\\n     * @notice Checks whether a certain address (claimant) may claim a given guild tag\\n     * @param guildHash The ENS namehash of the guild's domain\\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\\n     * @param claimant The address attempting to claim the tag (not necessarily the address that will receive it)\\n     * @param recipient The address that would receive the tag\\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\\n     */\\n    function canClaimTag(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Called by ENSGuilds once a tag has been claimed.\\n     * Provided for auth policies to update local state, such as erasing an address from an allowlist after that\\n     * address has successfully minted a tag.\\n     * @param guildHash The ENS namehash of the guild's domain\\n     * @param tag The tag being claimed (e.g. 'foo' for foo.my-guild.eth)\\n     * @param claimant The address that claimed the tag (not necessarily the address that received it)\\n     * @param recipient The address that received receive the tag\\n     * @param extraClaimArgs [Optional] Any guild-specific additional arguments required\\n     * @return tagHashToRevoke The ENS namehash of any tag that should be revoked as a consequence of the given tag\\n     * being claimed. Returns zero if no tag should be revoked.\\n     */\\n    function onTagClaimed(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address recipient,\\n        bytes calldata extraClaimArgs\\n    ) external returns (bytes32 tagHashToRevoke);\\n\\n    /**\\n     * @notice Checks whether a given guild tag is eligible to be revoked\\n     * @param revokedBy The address that would attempt to revoke it\\n     * @param guildHash The ENS namehash of the guild's domain\\n     * @param tag The tag being revoked (e.g. 'foo' for foo.my-guild.eth)\\n     * @param extraRevokeArgs Any additional arguments necessary for assessing whether a tag may be revoked\\n     */\\n    function tagCanBeRevoked(\\n        address revokedBy,\\n        bytes32 guildHash,\\n        string calldata tag,\\n        bytes calldata extraRevokeArgs\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc102bd8b8ad396612893f2fce271d56e7b80388ab2df80ee24934d62baf8af89\",\"license\":\"MIT\"},\"contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport \\\"../libraries/StringParsing.sol\\\";\\nimport \\\"./BaseTagsAuthPolicy.sol\\\";\\n\\n/**\\n * @title NFTTagsAuthPolicy\\n * @notice A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses\\n * that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once\\n * per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being\\n * revoked once the second is minted, regardless of whether ownership of that TokenID has changed.\\n *\\n * A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.\\n */\\ncontract NFTTagsAuthPolicy is BaseTagsAuthPolicy {\\n    using ERC165Checker for address;\\n    using StringParsing for bytes;\\n\\n    error TokenIDTagMustMatchCallerTokenID();\\n\\n    enum TokenStandard {\\n        ERC721,\\n        ERC1155\\n    }\\n    struct TagClaim {\\n        bytes32 tagHash;\\n        address claimedBy;\\n    }\\n    struct GuildInfo {\\n        address tokenContract;\\n        TokenStandard tokenStandard;\\n        mapping(uint256 => TagClaim) tagClaims;\\n    }\\n    mapping(bytes32 => GuildInfo) public guilds;\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(IENSGuilds ensGuilds) BaseTagsAuthPolicy(ensGuilds) {}\\n\\n    /**\\n     * @notice Registers the specific NFT collection that a user must be a member of to mint a guild tag\\n     * @param guildHash The ENS namehash of the guild's domain\\n     * @param tokenContract The ERC721 or ERC1155 collection to use\\n     */\\n    function setTokenContract(bytes32 guildHash, address tokenContract) external {\\n        // caller must be guild admin\\n        // solhint-disable-next-line reason-string\\n        require(_ensGuilds.guildAdmin(guildHash) == _msgSender());\\n\\n        // token contract must be ERC721 or ERC1155\\n        if (tokenContract.supportsInterface(type(IERC721).interfaceId)) {\\n            guilds[guildHash].tokenStandard = TokenStandard.ERC721;\\n        } else if (tokenContract.supportsInterface(type(IERC1155).interfaceId)) {\\n            guilds[guildHash].tokenStandard = TokenStandard.ERC1155;\\n        } else {\\n            // solhint-disable-next-line reason-string\\n            revert();\\n        }\\n\\n        guilds[guildHash].tokenContract = tokenContract;\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     * @dev Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`.\\n     * The caller must own the given TokenID.\\n     */\\n    function canClaimTag(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address,\\n        bytes calldata extraClaimArgs\\n    ) external view virtual override returns (bool) {\\n        GuildInfo storage guildInfo = guilds[guildHash];\\n        address tokenContract = guildInfo.tokenContract;\\n\\n        // parse NFT token ID from the tag claim args\\n        if (extraClaimArgs.length != 32) {\\n            return false;\\n        }\\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\\n\\n        // check that claimant owns this NFT\\n        bool ownsNFT = false;\\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\\n            ownsNFT = IERC721(tokenContract).ownerOf(nftTokenId) == claimant;\\n        } else {\\n            ownsNFT = IERC1155(tokenContract).balanceOf(claimant, nftTokenId) > 0;\\n        }\\n        if (!ownsNFT) {\\n            return false;\\n        }\\n\\n        // if the tag looks like a token ID, it should be the same as the token ID\\n        // used to authorize the mint\\n        (bool isUint, uint256 parsedTokenID) = bytes(tag).parseUint256();\\n        if (isUint && parsedTokenID != nftTokenId) {\\n            revert TokenIDTagMustMatchCallerTokenID();\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev records the latest tag minted from the given TokenID (via extraClaimArgs), and returns whichever\\n     * tag was last minted from the same TokenID.\\n     */\\n    function _onTagClaimed(\\n        bytes32 guildHash,\\n        string calldata tag,\\n        address claimant,\\n        address,\\n        bytes calldata extraClaimArgs\\n    ) internal virtual override returns (bytes32 tagToRevoke) {\\n        bytes32 tagHash = keccak256(bytes(tag));\\n        uint256 nftTokenId = uint256(bytes32(extraClaimArgs));\\n\\n        tagToRevoke = guilds[guildHash].tagClaims[nftTokenId].tagHash;\\n\\n        guilds[guildHash].tagClaims[nftTokenId].tagHash = tagHash;\\n        guilds[guildHash].tagClaims[nftTokenId].claimedBy = claimant;\\n\\n        return tagToRevoke;\\n    }\\n\\n    /**\\n     * @inheritdoc ITagsAuthPolicy\\n     */\\n    function tagCanBeRevoked(\\n        address,\\n        bytes32 guildHash,\\n        string calldata tag,\\n        bytes calldata extraRevokeArgs\\n    ) external view virtual override returns (bool) {\\n        bytes32 tagHash = keccak256(bytes(tag));\\n\\n        if (extraRevokeArgs.length != 32) {\\n            return false;\\n        }\\n        uint256 nftTokenId = uint256(bytes32(extraRevokeArgs));\\n\\n        GuildInfo storage guildInfo = guilds[guildHash];\\n        address tokenContract = guildInfo.tokenContract;\\n\\n        // check that the given tag was indeed claimed from the given NFT\\n        if (guildInfo.tagClaims[nftTokenId].tagHash != tagHash) {\\n            return false;\\n        }\\n\\n        // check that the current owner of the given NFT is the same as the owner when the tag was claimed\\n        address previousClaimant = guildInfo.tagClaims[nftTokenId].claimedBy;\\n        if (guildInfo.tokenStandard == TokenStandard.ERC721) {\\n            address currentTokenOwner = IERC721(tokenContract).ownerOf(nftTokenId);\\n            return currentTokenOwner != previousClaimant;\\n        } else {\\n            return IERC1155(tokenContract).balanceOf(previousClaimant, nftTokenId) == 0;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54197df0422254245a06f2fe4fde9c0969cd517e429ca5352ac1c105f32036e4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610e1c380380610e1c83398101604081905261002f916100c0565b60016000556040516301ffc9a760e01b81526340b9de5d60e11b600482015281906001600160a01b038216906301ffc9a790602401602060405180830381865afa158015610081573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100a591906100f0565b6100ae57600080fd5b6001600160a01b031660805250610112565b6000602082840312156100d257600080fd5b81516001600160a01b03811681146100e957600080fd5b9392505050565b60006020828403121561010257600080fd5b815180151581146100e957600080fd5b608051610ce86101346000396000818161034001526105820152610ce86000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c80632cad1767116100505780632cad1767146100d357806351338849146100e6578063d919713f146100fb57600080fd5b806301ffc9a7146100775780630910b77f1461009f57806329593e5a146100b2575b600080fd5b61008a6100853660046109a8565b61013e565b60405190151581526020015b60405180910390f35b61008a6100ad366004610a2c565b610175565b6100c56100c0366004610a2c565b610333565b604051908152602001610096565b61008a6100e1366004610acf565b61038d565b6100f96100f4366004610b5b565b61055f565b005b610130610109366004610b8b565b6001602052600090815260409020546001600160a01b03811690600160a01b900460ff1682565b604051610096929190610bba565b60006001600160e01b031982166306724f2160e11b148061016f57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60008781526001602090815260408220805490916001600160a01b039091169084146101a657600092505050610328565b60006101b28587610bf5565b90506000808454600160a01b900460ff1660018111156101d4576101d4610ba4565b03610258576040516331a9108f60e11b8152600481018390526001600160a01b03808b169190851690636352211e90602401602060405180830381865afa158015610223573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102479190610c13565b6001600160a01b03161490506102cf565b604051627eeac760e11b81526001600160a01b038a81166004830152602482018490526000919085169062fdd58e90604401602060405180830381865afa1580156102a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102cb9190610c30565b1190505b806102e1576000945050505050610328565b6000806102ee8d8d6106c6565b915091508180156102ff5750838114155b1561031d5760405163398a3b7d60e21b815260040160405180910390fd5b600196505050505050505b979650505050505050565b600061033d6107d6565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461037257600080fd5b61038188888888888888610833565b90506103286001600055565b60008085856040516103a0929190610c49565b6040519081900390209050602083146103bd576000915050610555565b60006103c98486610bf5565b600089815260016020818152604080842080548686529381019092529092205492935090916001600160a01b0390911690841461040d576000945050505050610555565b600083815260018084016020526040822001546001600160a01b0316908354600160a01b900460ff16600181111561044757610447610ba4565b036104dd576040516331a9108f60e11b8152600481018590526000906001600160a01b03841690636352211e90602401602060405180830381865afa158015610494573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b89190610c13565b9050816001600160a01b0316816001600160a01b031614159650505050505050610555565b604051627eeac760e11b81526001600160a01b0382811660048301526024820186905283169062fdd58e90604401602060405180830381865afa158015610528573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054c9190610c30565b15955050505050505b9695505050505050565b3360405163022c977f60e01b8152600481018490526001600160a01b03918216917f0000000000000000000000000000000000000000000000000000000000000000169063022c977f90602401602060405180830381865afa1580156105c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ed9190610c13565b6001600160a01b03161461060057600080fd5b61061a6001600160a01b0382166380ac58cd60e01b6108b8565b15610647576000828152600160205260408120805460ff60a01b1916600160a01b835b021790555061068b565b6106616001600160a01b038216636cdb3d1360e11b6108b8565b15610072576000828152600160208190526040909120805460ff60a01b1916600160a01b8361063d565b600091825260016020526040909120805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b600080805b838110156107c957600360fc1b8585838181106106ea576106ea610c59565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191610806107625750603960f81b85858381811061073457610734610c59565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916115b156107745760008092509250506107cf565b6000603086868481811061078a5761078a610c59565b61079b9392013560f81c9050610c85565b9050806107a984600a610c98565b6107b39190610caf565b92505080806107c190610cc2565b9150506106cb565b60019250505b9250929050565b60026000540361082c5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640160405180910390fd5b6002600055565b6000808787604051610846929190610c49565b6040519081900390209050600061085d8486610bf5565b60009a8b52600160208181526040808e20938e5292820190529a208054928155909901805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03979097169690961790955550929695505050505050565b60006108c3836108db565b80156108d457506108d4838361090e565b9392505050565b60006108ee826301ffc9a760e01b61090e565b801561016f5750610907826001600160e01b031961090e565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015610995575060208210155b8015610328575015159695505050505050565b6000602082840312156109ba57600080fd5b81356001600160e01b0319811681146108d457600080fd5b60008083601f8401126109e457600080fd5b50813567ffffffffffffffff8111156109fc57600080fd5b6020830191508360208285010111156107cf57600080fd5b6001600160a01b0381168114610a2957600080fd5b50565b600080600080600080600060a0888a031215610a4757600080fd5b87359650602088013567ffffffffffffffff80821115610a6657600080fd5b610a728b838c016109d2565b909850965060408a01359150610a8782610a14565b909450606089013590610a9982610a14565b90935060808901359080821115610aaf57600080fd5b50610abc8a828b016109d2565b989b979a50959850939692959293505050565b60008060008060008060808789031215610ae857600080fd5b8635610af381610a14565b955060208701359450604087013567ffffffffffffffff80821115610b1757600080fd5b610b238a838b016109d2565b90965094506060890135915080821115610b3c57600080fd5b50610b4989828a016109d2565b979a9699509497509295939492505050565b60008060408385031215610b6e57600080fd5b823591506020830135610b8081610a14565b809150509250929050565b600060208284031215610b9d57600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03831681526040810160028310610be857634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b8035602083101561016f57600019602084900360031b1b1692915050565b600060208284031215610c2557600080fd5b81516108d481610a14565b600060208284031215610c4257600080fd5b5051919050565b8183823760009101908152919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561016f5761016f610c6f565b808202811582820484141761016f5761016f610c6f565b8082018082111561016f5761016f610c6f565b600060018201610cd457610cd4610c6f565b506001019056fea164736f6c6343000811000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100725760003560e01c80632cad1767116100505780632cad1767146100d357806351338849146100e6578063d919713f146100fb57600080fd5b806301ffc9a7146100775780630910b77f1461009f57806329593e5a146100b2575b600080fd5b61008a6100853660046109a8565b61013e565b60405190151581526020015b60405180910390f35b61008a6100ad366004610a2c565b610175565b6100c56100c0366004610a2c565b610333565b604051908152602001610096565b61008a6100e1366004610acf565b61038d565b6100f96100f4366004610b5b565b61055f565b005b610130610109366004610b8b565b6001602052600090815260409020546001600160a01b03811690600160a01b900460ff1682565b604051610096929190610bba565b60006001600160e01b031982166306724f2160e11b148061016f57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60008781526001602090815260408220805490916001600160a01b039091169084146101a657600092505050610328565b60006101b28587610bf5565b90506000808454600160a01b900460ff1660018111156101d4576101d4610ba4565b03610258576040516331a9108f60e11b8152600481018390526001600160a01b03808b169190851690636352211e90602401602060405180830381865afa158015610223573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102479190610c13565b6001600160a01b03161490506102cf565b604051627eeac760e11b81526001600160a01b038a81166004830152602482018490526000919085169062fdd58e90604401602060405180830381865afa1580156102a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102cb9190610c30565b1190505b806102e1576000945050505050610328565b6000806102ee8d8d6106c6565b915091508180156102ff5750838114155b1561031d5760405163398a3b7d60e21b815260040160405180910390fd5b600196505050505050505b979650505050505050565b600061033d6107d6565b337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161461037257600080fd5b61038188888888888888610833565b90506103286001600055565b60008085856040516103a0929190610c49565b6040519081900390209050602083146103bd576000915050610555565b60006103c98486610bf5565b600089815260016020818152604080842080548686529381019092529092205492935090916001600160a01b0390911690841461040d576000945050505050610555565b600083815260018084016020526040822001546001600160a01b0316908354600160a01b900460ff16600181111561044757610447610ba4565b036104dd576040516331a9108f60e11b8152600481018590526000906001600160a01b03841690636352211e90602401602060405180830381865afa158015610494573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b89190610c13565b9050816001600160a01b0316816001600160a01b031614159650505050505050610555565b604051627eeac760e11b81526001600160a01b0382811660048301526024820186905283169062fdd58e90604401602060405180830381865afa158015610528573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061054c9190610c30565b15955050505050505b9695505050505050565b3360405163022c977f60e01b8152600481018490526001600160a01b03918216917f0000000000000000000000000000000000000000000000000000000000000000169063022c977f90602401602060405180830381865afa1580156105c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ed9190610c13565b6001600160a01b03161461060057600080fd5b61061a6001600160a01b0382166380ac58cd60e01b6108b8565b15610647576000828152600160205260408120805460ff60a01b1916600160a01b835b021790555061068b565b6106616001600160a01b038216636cdb3d1360e11b6108b8565b15610072576000828152600160208190526040909120805460ff60a01b1916600160a01b8361063d565b600091825260016020526040909120805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03909216919091179055565b600080805b838110156107c957600360fc1b8585838181106106ea576106ea610c59565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191610806107625750603960f81b85858381811061073457610734610c59565b9050013560f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916115b156107745760008092509250506107cf565b6000603086868481811061078a5761078a610c59565b61079b9392013560f81c9050610c85565b9050806107a984600a610c98565b6107b39190610caf565b92505080806107c190610cc2565b9150506106cb565b60019250505b9250929050565b60026000540361082c5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640160405180910390fd5b6002600055565b6000808787604051610846929190610c49565b6040519081900390209050600061085d8486610bf5565b60009a8b52600160208181526040808e20938e5292820190529a208054928155909901805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b03979097169690961790955550929695505050505050565b60006108c3836108db565b80156108d457506108d4838361090e565b9392505050565b60006108ee826301ffc9a760e01b61090e565b801561016f5750610907826001600160e01b031961090e565b1592915050565b604080516001600160e01b03198316602480830191909152825180830390910181526044909101909152602080820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff166301ffc9a760e01b178152825160009392849283928392918391908a617530fa92503d91506000519050828015610995575060208210155b8015610328575015159695505050505050565b6000602082840312156109ba57600080fd5b81356001600160e01b0319811681146108d457600080fd5b60008083601f8401126109e457600080fd5b50813567ffffffffffffffff8111156109fc57600080fd5b6020830191508360208285010111156107cf57600080fd5b6001600160a01b0381168114610a2957600080fd5b50565b600080600080600080600060a0888a031215610a4757600080fd5b87359650602088013567ffffffffffffffff80821115610a6657600080fd5b610a728b838c016109d2565b909850965060408a01359150610a8782610a14565b909450606089013590610a9982610a14565b90935060808901359080821115610aaf57600080fd5b50610abc8a828b016109d2565b989b979a50959850939692959293505050565b60008060008060008060808789031215610ae857600080fd5b8635610af381610a14565b955060208701359450604087013567ffffffffffffffff80821115610b1757600080fd5b610b238a838b016109d2565b90965094506060890135915080821115610b3c57600080fd5b50610b4989828a016109d2565b979a9699509497509295939492505050565b60008060408385031215610b6e57600080fd5b823591506020830135610b8081610a14565b809150509250929050565b600060208284031215610b9d57600080fd5b5035919050565b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03831681526040810160028310610be857634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b8035602083101561016f57600019602084900360031b1b1692915050565b600060208284031215610c2557600080fd5b81516108d481610a14565b600060208284031215610c4257600080fd5b5051919050565b8183823760009101908152919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561016f5761016f610c6f565b808202811582820484141761016f5761016f610c6f565b8082018082111561016f5761016f610c6f565b600060018201610cd457610cd4610c6f565b506001019056fea164736f6c6343000811000a",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "canClaimTag(bytes32,string,address,address,bytes)": {
        "details": "Expects that the caller will supply the NFT's TokenID in `extraClaimArgs`. The caller must own the given TokenID.",
        "params": {
          "claimant": "The address attempting to claim the tag (not necessarily the address that will receive it)",
          "extraClaimArgs": "[Optional] Any guild-specific additional arguments required",
          "guildHash": "The ENS namehash of the guild's domain",
          "recipient": "The address that would receive the tag",
          "tag": "The tag being claimed (e.g. 'foo' for foo.my-guild.eth)"
        }
      },
      "onTagClaimed(bytes32,string,address,address,bytes)": {
        "details": "protects against reentrancy and checks that caller is the Guilds contract. Updating any state is deferred to the implementation.",
        "params": {
          "claimant": "The address that claimed the tag (not necessarily the address that received it)",
          "extraClaimArgs": "[Optional] Any guild-specific additional arguments required",
          "guildHash": "The ENS namehash of the guild's domain",
          "recipient": "The address that received receive the tag",
          "tag": "The tag being claimed (e.g. 'foo' for foo.my-guild.eth)"
        },
        "returns": {
          "tagToRevoke": "The ENS namehash of any tag that should be revoked as a consequence of the given tag being claimed. Returns zero if no tag should be revoked."
        }
      },
      "setTokenContract(bytes32,address)": {
        "params": {
          "guildHash": "The ENS namehash of the guild's domain",
          "tokenContract": "The ERC721 or ERC1155 collection to use"
        }
      },
      "tagCanBeRevoked(address,bytes32,string,bytes)": {
        "params": {
          "extraRevokeArgs": "Any additional arguments necessary for assessing whether a tag may be revoked",
          "guildHash": "The ENS namehash of the guild's domain",
          "revokedBy": "The address that would attempt to revoke it",
          "tag": "The tag being revoked (e.g. 'foo' for foo.my-guild.eth)"
        }
      }
    },
    "title": "NFTTagsAuthPolicy",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "canClaimTag(bytes32,string,address,address,bytes)": {
        "notice": "Checks whether a certain address (claimant) may claim a given guild tag"
      },
      "setTokenContract(bytes32,address)": {
        "notice": "Registers the specific NFT collection that a user must be a member of to mint a guild tag"
      },
      "tagCanBeRevoked(address,bytes32,string,bytes)": {
        "notice": "Checks whether a given guild tag is eligible to be revoked"
      }
    },
    "notice": "A common implementation of TagsAuthPolicy that can be used to restrict minting guild tags to only addresses that own an NFT from a given collection, configured per-guild by each guild's admin. An address may mint a tag once per each item in the collection that it owns. Minting two tags from the same TokenID will result in the first being revoked once the second is minted, regardless of whether ownership of that TokenID has changed. A user's guild tag is eligible for revocation once that user ceases to own the TokenID used in minting that tag.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 61,
        "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 1120,
        "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
        "label": "guilds",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_struct(GuildInfo)1115_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_enum(TokenStandard)1099": {
        "encoding": "inplace",
        "label": "enum NFTTagsAuthPolicy.TokenStandard",
        "numberOfBytes": "1"
      },
      "t_mapping(t_bytes32,t_struct(GuildInfo)1115_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct NFTTagsAuthPolicy.GuildInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(GuildInfo)1115_storage"
      },
      "t_mapping(t_uint256,t_struct(TagClaim)1104_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct NFTTagsAuthPolicy.TagClaim)",
        "numberOfBytes": "32",
        "value": "t_struct(TagClaim)1104_storage"
      },
      "t_struct(GuildInfo)1115_storage": {
        "encoding": "inplace",
        "label": "struct NFTTagsAuthPolicy.GuildInfo",
        "members": [
          {
            "astId": 1106,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tokenContract",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1109,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tokenStandard",
            "offset": 20,
            "slot": "0",
            "type": "t_enum(TokenStandard)1099"
          },
          {
            "astId": 1114,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tagClaims",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(TagClaim)1104_storage)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TagClaim)1104_storage": {
        "encoding": "inplace",
        "label": "struct NFTTagsAuthPolicy.TagClaim",
        "members": [
          {
            "astId": 1101,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "tagHash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 1103,
            "contract": "contracts/tagsAuthPolicies/NFTTagsAuthPolicy.sol:NFTTagsAuthPolicy",
            "label": "claimedBy",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}